<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ad Context Protocol Testing Framework v2.1</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        /* CSS Custom Properties for Theming */
        :root {
            /* Primary gradients */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --success-gradient: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            --warning-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --danger-gradient: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
            
            /* Glass morphism effects */
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            
            /* Semantic colors */
            --surface-primary: rgba(255, 255, 255, 0.95);
            --surface-secondary: rgba(248, 250, 252, 0.8);
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --text-muted: #718096;
            
            /* Interactive colors */
            --accent-blue: #4299e1;
            --accent-purple: #9f7aea;
            --accent-green: #48bb78;
            --accent-orange: #ed8936;
            
            /* Animation timing */
            --timing-fast: 0.2s;
            --timing-normal: 0.4s;
            --timing-slow: 0.6s;
            --easing: cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Modern Typography System */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
            line-height: 1.6;
            color: var(--text-primary);
            font-weight: 400;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            max-width: 1600px;
            margin: 0 auto;
            padding: 0;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        /* Typography Styles */
        h1 {
            font-size: clamp(2rem, 4vw, 2.75rem);
            font-weight: 800;
            letter-spacing: -0.025em;
            line-height: 1.2;
            background: linear-gradient(135deg, #1a4d3a 0%, #2d7a5a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        h3 {
            font-size: clamp(1.25rem, 2vw, 1.5rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .subtitle {
            font-size: clamp(1rem, 2vw, 1.125rem);
            color: var(--text-secondary);
            font-weight: 500;
            margin-bottom: 2rem;
            line-height: 1.5;
        }

        /* Enhanced Header Design */
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 24px 40px;
            box-shadow: 
                0 8px 32px rgba(30, 60, 114, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.15);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3), transparent 50%),
                       radial-gradient(circle at 80% 20%, rgba(255, 114, 94, 0.3), transparent 50%);
            pointer-events: none;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(45deg, #fff, #e8f4fd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }
        /* Main Content & Card System */
        .main-content {
            padding: 30px;
            margin: 20px;
            transition: margin-right var(--timing-normal) var(--easing);
        }
        
        .main-content.debug-open {
            /* No margin adjustment needed - debug panel is now at bottom */
        }

        /* Top Navigation */
        .top-nav {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }

        .nav-brand h2 {
            color: white;
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .nav-links {
            display: flex;
            gap: 30px;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 14px;
        }

        .nav-link:hover {
            color: white;
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        .nav-link.active {
            color: white;
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Task Notification Badge */
        .task-notification-badge {
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .task-notification-badge:hover {
            color: white !important;
            background: rgba(255, 255, 255, 0.15) !important;
        }

        .task-notification-badge.has-tasks {
            animation: pulse 2s infinite;
        }

        .task-notification-badge #task-count {
            background: #ff4757;
            color: white;
            font-size: 11px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            min-width: 18px;
            text-align: center;
            display: inline-block;
        }

        .task-notification-badge #task-count.zero {
            background: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Task Panel */
        .task-panel {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 400px;
            max-height: 500px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 1002;
            transform: translateY(-10px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .task-panel.open {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }

        .task-panel-header {
            padding: 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-panel-title {
            font-size: 16px;
            font-weight: 700;
            color: #2d3748;
            margin: 0;
        }

        .task-panel-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #718096;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .task-panel-close:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #2d3748;
        }

        .task-panel-content {
            max-height: 400px;
            overflow-y: auto;
            padding: 0;
        }

        .task-item {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            transition: background 0.2s;
        }

        .task-item:last-child {
            border-bottom: none;
        }

        .task-item:hover {
            background: rgba(0, 0, 0, 0.02);
        }

        .task-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .task-item-title {
            font-size: 14px;
            font-weight: 600;
            color: #2d3748;
            margin: 0;
        }

        .task-item-status {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 3px 8px;
            border-radius: 12px;
            letter-spacing: 0.5px;
        }

        .task-item-status.submitted {
            background: #e3f2fd;
            color: #1976d2;
        }

        .task-item-status.working {
            background: #fff3e0;
            color: #f57c00;
            animation: working-pulse 1.5s infinite;
        }

        .task-item-status.completed {
            background: #e8f5e8;
            color: #388e3c;
        }

        .task-item-status.failed {
            background: #ffebee;
            color: #d32f2f;
        }

        .task-item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #718096;
        }

        .task-item-agent {
            font-weight: 500;
            color: #4a5568;
        }

        .task-item-time {
            font-family: monospace;
        }

        .task-empty-state {
            padding: 40px 20px;
            text-align: center;
            color: #718096;
        }

        .task-empty-state .empty-icon {
            font-size: 32px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        @keyframes working-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Adjust main content to account for navigation */
        .main-content {
            margin-top: 0;
        }

        /* Glass-morphic Card Design */
        .section, .available-products, .creative-formats, .active-media-buys {
            background: var(--surface-primary);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 32px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.08),
                0 1px 3px rgba(0, 0, 0, 0.12);
            transition: all var(--timing-normal) var(--easing);
            position: relative;
            overflow: hidden;
        }

        .section::before, .available-products::before, .creative-formats::before, .active-media-buys::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-gradient);
            border-radius: 16px 16px 0 0;
        }

        .section:hover, .available-products:hover, .creative-formats:hover, .active-media-buys:hover {
            transform: translateY(-4px);
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.12),
                0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        /* Glassmorphic Debug Panel - Bottom Positioned */
        .debug-panel {
            position: fixed;
            bottom: -400px;
            left: 0;
            right: 0;
            width: 100%;
            height: 400px;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 -8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 1px rgba(255, 255, 255, 0.1);
            transition: bottom var(--timing-normal) var(--easing);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            color: #f0f0f0;
        }
        
        .debug-panel.open {
            bottom: 0;
        }
        
        .debug-header {
            background: rgba(45, 45, 45, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .debug-header h3 {
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            font-size: 16px;
            margin: 0;
        }
        
        .debug-controls {
            display: flex;
            gap: 10px;
        }
        
        .debug-btn {
            background: #444;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .debug-btn:hover {
            background: #555;
        }
        
        .debug-tabs {
            display: flex;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
        }
        
        .tab-btn {
            flex: 1;
            padding: 10px;
            background: transparent;
            color: #999;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tab-btn.active {
            background: #1a1a1a;
            color: #00ff00;
            border-bottom: 2px solid #00ff00;
        }
        
        .tab-btn:hover:not(.active) {
            background: #333;
        }
        
        .debug-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .debug-entry {
            margin-bottom: 15px;
            padding: 10px;
            background: #2d2d2d;
            border-radius: 4px;
            border-left: 3px solid #666;
        }
        
        .debug-entry.request {
            border-left-color: #4a9eff;
        }
        
        .debug-entry.response {
            border-left-color: #00ff00;
        }
        
        .debug-entry.error {
            border-left-color: #ff4444;
        }
        
        .debug-entry.validation {
            border-left-color: #ff9500;
        }
        
        .validation-status {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
        }
        
        .validation-status.valid {
            background: #00ff00;
            color: #000;
        }
        
        .validation-status.invalid {
            background: #ff4444;
            color: #fff;
        }
        
        .validation-status.unknown {
            background: #666;
            color: #fff;
        }
        
        .validation-details {
            margin-top: 8px;
            font-size: 12px;
        }
        
        .validation-error {
            background: #2a1515;
            border: 1px solid #ff4444;
            border-radius: 3px;
            padding: 8px;
            margin: 4px 0;
        }
        
        .validation-summary {
            color: #ccc;
            margin-bottom: 8px;
        }
        
        .copy-debug-btn {
            background: #4a5568;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-right: 8px;
            transition: background-color 0.2s;
        }
        
        .copy-debug-btn:hover {
            background: #2d3748;
        }
        
        .validation-context {
            background: #1a202c;
            border: 1px solid #2d3748;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        .validation-context a {
            color: #63b3ed;
            text-decoration: none;
        }
        
        .validation-context a:hover {
            text-decoration: underline;
        }
        
        .validation-product-errors {
            margin-top: 12px;
        }
        
        .validation-product-error {
            font-size: 11px;
        }
        
        .debug-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .debug-entry-title {
            font-weight: bold;
            font-size: 12px;
        }
        
        .debug-entry-time {
            font-size: 11px;
            color: #999;
        }
        
        .debug-entry-details {
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        
        .debug-json {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 3px;
            overflow-x: auto;
            margin-top: 5px;
        }
        
        .debug-json pre {
            margin: 0;
            color: #f0f0f0;
        }
        
        .debug-copy-btn {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .debug-copy-btn:hover {
            background: #3a8eef;
        }
        
        .debug-status {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .debug-status.success {
            background: #00ff00;
            color: #000;
        }
        
        .debug-status.error {
            background: #ff4444;
            color: #fff;
        }
        
        .debug-status.pending {
            background: #ffa500;
            color: #000;
        }
        
        .debug-timing {
            margin-top: 5px;
            font-size: 11px;
        }
        
        .debug-timing-bar {
            height: 4px;
            background: #444;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 3px;
        }
        
        .debug-timing-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #00ff00);
            transition: width 0.3s ease;
        }
        
        .toggle-debug-btn {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: #1a4d3a;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1001;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }
        
        /* Move toggle button up when debug panel is open */
        .toggle-debug-btn.panel-open {
            bottom: 420px; /* 400px panel height + 20px margin */
        }
        
        .toggle-debug-btn:hover {
            background: #2a5d4a;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }
        
        /* Debug Pair Styles */
        .debug-pair {
            margin-bottom: 15px;
            background: #2d2d2d;
            border-radius: 4px;
            border-left: 3px solid #4a9eff;
        }
        
        .debug-pair.error {
            border-left-color: #ff4444;
        }
        
        .debug-pair-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            background: #333;
            border-radius: 4px 4px 0 0;
            transition: background 0.2s;
        }
        
        .debug-pair-header:hover {
            background: #3a3a3a;
        }
        
        .debug-pair-title {
            font-weight: bold;
            font-size: 13px;
            color: #f0f0f0;
        }
        
        .debug-pair-time {
            font-size: 11px;
            color: #999;
        }
        
        .debug-pair-toggle {
            font-size: 12px;
            color: #999;
            margin-left: 10px;
        }
        
        .debug-pair-content {
            display: none;
            padding: 15px;
            border-top: 1px solid #444;
        }
        
        /* Operation-specific styles */
        .debug-pair.operation {
            border-left-color: #9C27B0;
        }
        
        .debug-pair-meta {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 11px;
        }
        
        .debug-pair-agent {
            color: #4CAF50;
            font-weight: 600;
        }
        
        .debug-pair-duration {
            color: #FF9800;
            font-family: monospace;
            background: #444;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .operation-summary {
            font-size: 12px;
            line-height: 1.5;
        }
        
        .operation-steps {
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a1a;
        }
        
        .operation-step {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 12px;
            border-bottom: 1px solid #333;
            font-size: 11px;
        }
        
        .operation-step:last-child {
            border-bottom: none;
        }
        
        .operation-step.success .step-status {
            color: #4CAF50;
        }
        
        .operation-step.error .step-status {
            color: #f44336;
        }
        
        .step-number {
            background: #666;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .step-name {
            flex: 1;
            font-weight: 500;
        }
        
        .step-status {
            font-family: monospace;
            font-weight: 600;
        }
        
        .step-duration {
            font-family: monospace;
            opacity: 0.7;
            font-size: 10px;
        }
        
        .operation-metadata {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        
        .operation-metadata strong {
            color: #4CAF50;
            font-size: 11px;
        }
        
        .json-data {
            background: #000;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 8px;
            margin-top: 5px;
            font-size: 10px;
            line-height: 1.3;
            overflow-x: auto;
        }
        
        .debug-section {
            margin-bottom: 20px;
        }
        
        .debug-section h4 {
            margin: 0 0 10px 0;
            color: #00ff00;
            font-size: 12px;
            font-weight: bold;
        }
        
        h1 {
            color: #1a4d3a;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 14px;
            margin-bottom: 30px;
        }
        
        /* Workflow Progress Styles */
        .workflow-progress {
            display: flex;
            justify-content: space-between;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .workflow-stage {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            margin: 0 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        
        .workflow-stage.active {
            background: #1a4d3a;
            color: white;
            border-color: #1a4d3a;
        }
        
        .workflow-stage.completed {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }
        
        .workflow-stage.pending-approval {
            background: #ffc107;
            color: #000;
            border-color: #ffc107;
            animation: pulse 2s infinite;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab-button {
            padding: 10px 20px;
            background: none;
            border: none;
            color: #666;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab-button.active {
            color: #1a4d3a;
            border-bottom-color: #1a4d3a;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .section h3 {
            color: #1a4d3a;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        /* Tool Testing Styles */
        .tool-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .tool-selector select {
            flex: 2;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .tool-params {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
        }
        
        .param-group {
            margin-bottom: 10px;
        }
        
        .param-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 13px;
            color: #333;
        }
        
        .param-group input,
        .param-group textarea,
        .param-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .param-group textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        /* Approval Workflow Styles */
        .approval-workflow {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .approval-stage-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
        }
        
        .approval-stage-card h4 {
            margin: 0 0 10px 0;
            color: #1a4d3a;
            font-size: 14px;
        }
        
        .approval-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .approval-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #6c757d;
        }
        
        .approval-indicator.pending {
            background: #ffc107;
            animation: pulse 2s infinite;
        }
        
        .approval-indicator.approved {
            background: #28a745;
        }
        
        .approval-indicator.rejected {
            background: #dc3545;
        }
        
        .approval-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        /* Modern Button System */
        .btn {
            position: relative;
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            font-family: inherit;
            transition: all var(--timing-normal) var(--easing);
            box-shadow: 
                0 4px 12px rgba(102, 126, 234, 0.3),
                0 1px 3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-transform: none;
            letter-spacing: 0.01em;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 24px rgba(102, 126, 234, 0.4),
                0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(0);
            transition-duration: 0.1s;
        }

        .btn:disabled {
            background: linear-gradient(135deg, #cbd5e0 0%, #a0aec0 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #718096 0%, #4a5568 100%);
            box-shadow: 0 4px 12px rgba(113, 128, 150, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 8px 24px rgba(113, 128, 150, 0.4);
        }

        .btn-danger {
            background: var(--danger-gradient);
            box-shadow: 0 4px 12px rgba(252, 70, 107, 0.3);
        }

        .btn-danger:hover {
            box-shadow: 0 8px 24px rgba(252, 70, 107, 0.4);
        }

        .btn-warning {
            background: var(--warning-gradient);
            box-shadow: 0 4px 12px rgba(240, 147, 251, 0.3);
        }

        .btn-warning:hover {
            box-shadow: 0 8px 24px rgba(240, 147, 251, 0.4);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 8px;
        }

        /* Button loading state */
        .btn.loading {
            pointer-events: none;
            position: relative;
            color: transparent;
        }

        .btn.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border-radius: 50%;
            border: 2px solid transparent;
            border-top-color: #ffffff;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modern Table Design */
        #products-table, #creative-formats-table, #media-buys-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            font-size: 14px;
        }

        #products-table th, #creative-formats-table th, #media-buys-table th {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            color: var(--text-primary);
            font-weight: 700;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 20px 24px;
            border-bottom: 2px solid #e2e8f0;
            text-align: left;
            position: relative;
        }

        #products-table td, #creative-formats-table td, #media-buys-table td {
            padding: 18px 24px;
            border-bottom: 1px solid #f1f5f9;
            transition: background-color var(--timing-fast) var(--easing);
            vertical-align: middle;
        }

        #products-table tr:hover td, 
        #creative-formats-table tr:hover td, 
        #media-buys-table tr:hover td {
            background-color: rgba(102, 126, 234, 0.05);
        }

        #products-table tr:last-child td,
        #creative-formats-table tr:last-child td,
        #media-buys-table tr:last-child td {
            border-bottom: none;
        }

        /* Skeleton loading for tables */
        .skeleton-row {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 4px;
            height: 20px;
            margin: 8px 0;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* Review Queue Styles */
        .review-queue {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .queue-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .queue-item.urgent {
            border-left: 4px solid #dc3545;
        }
        
        .queue-item.high {
            border-left: 4px solid #ffc107;
        }
        
        .queue-item.medium {
            border-left: 4px solid #17a2b8;
        }
        
        .queue-item.low {
            border-left: 4px solid #6c757d;
        }
        
        .queue-item-info {
            flex: 1;
        }
        
        .queue-item-title {
            font-weight: 500;
            margin-bottom: 4px;
        }
        
        .queue-item-time {
            font-size: 12px;
            color: #666;
        }
        
        /* Streaming Status Styles */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }
        
        .connection-indicator.connected {
            background: #28a745;
            animation: pulse 2s infinite;
        }
        
        .connection-indicator.connecting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }
        
        .event-log {
            background: #1a1a1a;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .event-entry {
            padding: 2px 0;
            border-bottom: 1px solid #333;
        }
        
        .event-entry:last-child {
            border-bottom: none;
        }
        
        .event-entry .timestamp {
            color: #999;
            margin-right: 10px;
        }
        
        .event-entry .event-type {
            color: #0ff;
            margin-right: 10px;
        }
        
        .event-entry.error {
            color: #f00;
        }
        
        .event-entry.success {
            color: #0f0;
        }
        
        .event-entry.warning {
            color: #ff0;
        }
        
        /* Protocol Compliance Styles */
        .test-suite {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .test-category {
            background: white;
            border: 1px solid #e0e0e0;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .test-category:hover {
            background: #f8f9fa;
        }
        
        .test-category.selected {
            background: #1a4d3a;
            color: white;
            border-color: #1a4d3a;
        }
        
        .compliance-results {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .test-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .test-result:last-child {
            border-bottom: none;
        }
        
        .test-result.pass {
            background: #d4edda;
        }
        
        .test-result.fail {
            background: #f8d7da;
        }
        
        .test-result.warning {
            background: #fff3cd;
        }
        
        .test-name {
            font-weight: 500;
            font-size: 13px;
        }
        
        .test-status {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 3px;
            background: #e9ecef;
        }
        
        .test-status.pass {
            background: #28a745;
            color: white;
        }
        
        .test-status.fail {
            background: #dc3545;
            color: white;
        }
        
        .test-status.warning {
            background: #ffc107;
            color: #000;
        }
        
        /* New Table Interface Styles */
        .connection-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .connection-indicator:empty {
            background-color: #6c757d;
        }
        
        .event-log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            overflow-y: auto;
        }
        
        .event-entry {
            margin: 5px 0;
            display: flex;
            gap: 10px;
        }
        
        .event-entry .timestamp {
            color: #6c757d;
            min-width: 80px;
        }
        
        .event-entry .event-type {
            color: #495057;
            font-weight: bold;
            min-width: 80px;
        }
        
        .btn-small {
            padding: 4px 8px !important;
            font-size: 12px !important;
            margin: 0 2px !important;
        }
        
        .btn-danger {
            background-color: #dc3545;
            border-color: #dc3545;
        }
        
        .btn-danger:hover {
            background-color: #c82333;
            border-color: #bd2130;
        }
        
        #products-table, #creative-formats-table, #media-buys-table {
            font-size: 13px;
        }
        
        #products-table th, #creative-formats-table th, #media-buys-table th {
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Loading and Animation Styles */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #1a4d3a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Debug Panel Styles */
        .debug-panel {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            margin-top: 20px;
        }
        
        .debug-header {
            background: #e9ecef;
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .debug-header:hover {
            background: #dee2e6;
        }
        
        .debug-content.legacy {
            padding: 15px;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .debug-content.legacy.expanded {
            display: block;
        }
        
        .debug-code {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            border: 1px solid #e9ecef;
        }
        
        .copy-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .copy-btn:hover {
            background: #5a6268;
        }

        /* Mobile-First Responsive Design */
        @media (max-width: 768px) {
            .main-content {
                margin: 10px;
                padding: 20px;
            }
            
            .section, .available-products, .creative-formats, .active-media-buys {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .header {
                padding: 16px 20px;
            }
            
            h1 {
                font-size: 1.75rem;
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 14px;
            }

            .main-content.debug-open {
                /* No margin adjustment needed - debug panel is now at bottom */
            }

            .debug-panel {
                height: 300px; /* Smaller height on mobile */
                bottom: -300px;
            }
            
            .toggle-debug-btn.panel-open {
                bottom: 320px; /* 300px panel height + 20px margin on mobile */
            }
            
            /* Stack tables vertically on mobile */
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                margin-bottom: 10px;
                padding: 10px;
                background: white;
            }
            
            td {
                border: none;
                position: relative;
                padding: 10px 10px 10px 35%;
                text-align: left;
            }
            
            td:before {
                content: attr(data-label) ": ";
                position: absolute;
                left: 10px;
                width: 30%;
                white-space: nowrap;
                font-weight: 600;
                color: var(--text-secondary);
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 12px 16px;
            }
            
            .logo {
                font-size: 18px;
            }
            
            .main-content {
                margin: 5px;
                padding: 15px;
            }
            
            .section, .available-products, .creative-formats, .active-media-buys {
                padding: 16px;
                margin-bottom: 16px;
                border-radius: 12px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 13px;
                border-radius: 8px;
            }
        }

        /* Reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
        /* Authentic Debug Log Styles */
        .debug-log-entry {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 4px;
            border-left: 3px solid;
        }
        
        .debug-log-entry.info {
            background: rgba(59, 130, 246, 0.1);
            border-left-color: #3b82f6;
        }
        
        .debug-log-entry.success {
            background: rgba(34, 197, 94, 0.1);
            border-left-color: #22c55e;
        }
        
        .debug-log-entry.error {
            background: rgba(239, 68, 68, 0.1);
            border-left-color: #ef4444;
        }
        
        .debug-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .debug-log-type {
            font-size: 11px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-primary);
        }
        
        .debug-log-time {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .debug-log-message {
            font-size: 13px;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        .debug-log-data {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            padding: 12px;
            font-size: 12px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            color: var(--text-secondary);
            margin: 8px 0;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
        }

        .debug-log-data.error {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: #dc2626;
        }
        
        /* Debug Call Card Styles */
        .debug-call-card {
            margin: 12px 0;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
        }
        
        .debug-call-card.success {
            border-left: 4px solid #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }
        
        .debug-call-card.error {
            border-left: 4px solid #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }
        
        .debug-call-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            user-select: none;
        }
        
        .debug-call-header:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .debug-call-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .debug-call-icon {
            font-size: 14px;
        }
        
        .debug-call-method {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .debug-call-status {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.8;
            color: var(--text-secondary);
        }
        
        .debug-call-timestamp {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .debug-call-toggle {
            font-size: 12px;
            color: var(--text-muted);
            transition: transform 0.2s ease;
        }
        
        .debug-call-details {
            padding: 0 16px 16px 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        .modal-content {
            background-color: white;
            margin: 40px auto;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal .close {
            color: #999;
            float: right;
            font-size: 28px;
            font-weight: bold;
            line-height: 20px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .modal .close:hover,
        .modal .close:focus {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            Ad Context Protocol
        </div>
    </div>

    <!-- Top Navigation -->
    <nav class="top-nav">
        <div class="nav-container">
            <div class="nav-brand">
                <h2>AdCP Testing Framework</h2>
            </div>
            <div class="nav-links">
                <a href="/" class="nav-link active">🧪 Media Buy Testing</a>
                <a href="/creative-testing.html" class="nav-link">🎨 Creative Agent Testing</a>
                <a href="/adagents.html" class="nav-link">🔗 AdAgents Manager</a>
                <div class="nav-link task-notification-badge" id="task-notification-badge" onclick="toggleTaskPanel()" title="Active Tasks">
                    📋 <span id="task-count">0</span>
                </div>
            </div>
        </div>
    </nav>

    <div class="main-content" id="main-content">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
            <div>
                <h1>Ad Context Protocol Testing Framework</h1>
                <p class="subtitle">Test advertising sales agents using MCP and A2A protocols</p>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label>Agent:</label>
                    <select id="agent-selector" style="min-width: 200px;" onchange="onAgentSelected()">
                        <option value="">Select an agent...</option>
                    </select>
                    <button id="refresh-agent-btn" class="btn btn-small" onclick="refreshAgentData()" disabled>🔄 Load Agent Data</button>
                    <button class="btn btn-secondary btn-small" onclick="toggleAddAgent()" id="add-toggle-btn">➕ Add Agent</button>
                    <button class="btn btn-small" onclick="viewAllAgents()" style="background-color: #28a745; color: white; margin-left: 5px;">📋 View All</button>
                </div>
            </div>
        </div>

        <!-- Add New Agent Form (collapsible) -->
        <div id="add-agent-form" style="display: none; margin: 15px 0; padding: 15px; border: 1px solid #dee2e6; border-radius: 4px; background: white;">
            <!-- Input Method Toggle -->
            <div style="margin-bottom: 15px;">
                <div style="display: flex; gap: 10px; border-bottom: 1px solid #dee2e6;">
                    <button type="button" class="btn-tab" id="manual-tab" onclick="switchInputMethod('manual')" style="background: #1a4d3a; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px 4px 0 0;">Manual Entry</button>
                    <button type="button" class="btn-tab" id="json-tab" onclick="switchInputMethod('json')" style="background: #6c757d; color: white; border: none; padding: 8px 16px; cursor: pointer; border-radius: 4px 4px 0 0;">Paste JSON</button>
                </div>
            </div>
            
            <!-- Manual Entry Form -->
            <div id="manual-entry" style="display: block;">
                <div class="param-group">
                    <label for="agent-name">Name:</label>
                    <input type="text" id="agent-name" placeholder="My Test Agent" />
                </div>
                <div class="param-group">
                    <label for="protocol">Protocol:</label>
                    <select id="protocol">
                        <option value="mcp">MCP</option>
                        <option value="a2a">A2A</option>
                    </select>
                </div>
                <div class="param-group">
                    <label for="agent-url">Server URL:</label>
                    <input type="text" id="agent-url" placeholder="https://your-agent.example.com" />
                </div>
                <div class="param-group">
                    <label for="auth-token">Auth Token (optional):</label>
                    <input type="password" id="auth-token" placeholder="Bearer token..." />
                </div>
            </div>
            
            <!-- JSON Entry Form -->
            <div id="json-entry" style="display: none;">
                <div class="param-group">
                    <label for="agent-json">Agent Configuration JSON:</label>
                    <textarea id="agent-json" placeholder='{
  "name": "My Test Agent",
  "agent_uri": "https://your-agent.example.com",
  "protocol": "mcp",
  "auth_token_env": "your-bearer-token"
}' style="height: 120px; font-family: 'Courier New', monospace; font-size: 13px;"></textarea>
                    <small style="display: block; color: #666; margin-top: 5px;">
                        💡 Paste agent JSON configuration. Supported fields: name, agent_uri, protocol, auth_token_env
                    </small>
                </div>
            </div>
            
            <div style="margin-top: 15px;">
                <button class="btn" onclick="addAgent()">Save Agent</button>
                <button class="btn btn-secondary" onclick="toggleAddAgent()">Cancel</button>
                <button class="btn btn-secondary" onclick="clearCustomAgentsFromStorage()" style="margin-left: 10px;">Clear All Custom Agents</button>
            </div>
        </div>

        <!-- Products Section -->
        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>📦 Available Products <span style="color: #666; font-size: 14px; font-weight: normal;">- Auto-loaded with agent data</span></h3>
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <input type="text"
                           id="promoted-offering-refresh"
                           placeholder="Brand name or manifest URL"
                           value="gourmet robot food"
                           style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; width: 200px;"
                           title="Brand name/description or URL to brand manifest JSON">

                    <select id="delivery-type-filter"
                            style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;"
                            title="Filter by delivery type">
                        <option value="">All Delivery Types</option>
                        <option value="guaranteed">Guaranteed</option>
                        <option value="non_guaranteed">Non-Guaranteed</option>
                    </select>

                    <select id="format-types-filter"
                            multiple
                            size="3"
                            style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; width: 120px;"
                            title="Filter by format types (Ctrl+click for multiple)">
                        <option value="video">Video</option>
                        <option value="display">Display</option>
                        <option value="audio">Audio</option>
                    </select>

                    <label style="display: flex; align-items: center; gap: 5px; font-size: 14px; cursor: pointer;"
                           title="Show only fixed-price products">
                        <input type="checkbox" id="fixed-price-filter">
                        Fixed Price Only
                    </label>

                    <input type="number"
                           id="min-exposures-filter"
                           placeholder="Min exposures"
                           min="0"
                           style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; width: 130px;"
                           title="Minimum impressions needed for measurement validity (e.g., 10000)">
                </div>
            </div>
            
            <div style="overflow-x: auto;">
                <table id="products-table" style="width: 100%; border-collapse: collapse; background: white;">
                    <thead style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                        <tr>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6; width: 40px;">
                                <input type="checkbox" id="select-all-products" onchange="toggleAllProducts()">
                            </th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Product ID</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Name</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Delivery Type</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">CPM</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Min Spend</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Formats</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6; width: 80px;">AdCP</th>
                        </tr>
                    </thead>
                    <tbody id="products-tbody">
                        <tr>
                            <td colspan="8" style="padding: 20px; text-align: center; color: #666;">
                                No products loaded. Click "Refresh Products" to discover available inventory.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div style="margin-top: 15px;">
                <button class="btn" onclick="createMediaBuyWithSelected()" id="create-buy-btn" disabled>Create Media Buy with Selected</button>
            </div>
        </div>

        <!-- Creative Formats Section -->
        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>🎨 Creative Formats</h3>
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <select id="format-type-filter"
                            style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;"
                            title="Filter by format type">
                        <option value="">All Types</option>
                        <option value="audio">Audio</option>
                        <option value="video">Video</option>
                        <option value="display">Display</option>
                    </select>

                    <select id="format-category-filter"
                            style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;"
                            title="Filter by category">
                        <option value="">All Categories</option>
                        <option value="standard">Standard</option>
                        <option value="custom">Custom</option>
                    </select>

                    <label style="display: flex; align-items: center; gap: 5px; font-size: 14px; cursor: pointer;"
                           title="Show only IAB standard formats">
                        <input type="checkbox" id="standard-only-filter">
                        IAB Standard Only
                    </label>

                    <span style="color: #666; font-size: 14px;">Auto-loaded with agent data</span>
                </div>
            </div>
            
            <div style="overflow-x: auto;">
                <table id="creative-formats-table" style="width: 100%; border-collapse: collapse; background: white;">
                    <thead style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                        <tr>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Format ID</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Name</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Type</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Dimensions</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6; width: 100px;">Generative</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Output Formats</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Assets Required</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6; width: 80px;">AdCP</th>
                        </tr>
                    </thead>
                    <tbody id="creative-formats-tbody">
                        <tr>
                            <td colspan="8" style="padding: 20px; text-align: center; color: #666;">
                                No creative formats loaded. Click "Refresh Creative Formats" to discover available formats.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Media Buys Section -->
        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>📊 Active Media Buys</h3>
                <button class="btn" onclick="refreshMediaBuys()">🔄 Refresh Media Buys</button>
            </div>
            
            <div style="overflow-x: auto;">
                <table id="media-buys-table" style="width: 100%; border-collapse: collapse; background: white;">
                    <thead style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                        <tr>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Media Buy ID</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Status</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Budget</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Spent</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Impressions</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">CTR</th>
                            <th style="padding: 12px; text-align: left; border: 1px solid #dee2e6;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="media-buys-tbody">
                        <tr>
                            <td colspan="7" style="padding: 20px; text-align: center; color: #666;">
                                No media buys found. Create a media buy to start tracking campaigns.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>


        <!-- Create Media Buy Modal -->
        <div id="create-media-buy-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 8px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
                <h3>Create New Media Buy</h3>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <h4>Selected Products:</h4>
                    <div id="selected-products-summary"></div>
                </div>
                
                <div class="param-group">
                    <label>Test Scenarios (optional):</label>
                    <select id="test-scenarios" onchange="loadTestScenario()">
                        <option value="">Select a test scenario...</option>
                        <optgroup label="Campaign Examples">
                            <option value="basic-campaign">Basic Campaign</option>
                            <option value="geo-targeted">Geo-Targeted Campaign</option>
                            <option value="axe-segments">AXE Segment Campaign</option>
                            <option value="frequency-capped">Frequency Capped Campaign</option>
                            <option value="premium-budget">Premium Budget Campaign</option>
                        </optgroup>
                        <optgroup label="AI-Powered Test Scenarios">
                            <option value="test-delay-response">Test: Delayed Response (10s)</option>
                            <option value="test-rejection">Test: Rejection Scenario</option>
                            <option value="test-human-approval">Test: Human Approval Workflow</option>
                            <option value="test-slow-delivery">Test: Slow Delivery + Outage</option>
                        </optgroup>
                    </select>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        Pre-populate fields with realistic test data or AI-powered test scenarios
                    </small>
                </div>
                
                <div class="param-group">
                    <label>Campaign Name:</label>
                    <input type="text" id="campaign-name" placeholder="My Campaign">
                </div>
                
                <div class="param-group">
                    <label>Buyer Reference (required):</label>
                    <input type="text" id="buyer-ref" placeholder="BUYER-2024-001" required>
                </div>
                
                <div class="param-group">
                    <label>PO Number (required):</label>
                    <input type="text" id="po-number" placeholder="PO-2024-001" required>
                </div>
                
                <div class="param-group">
                    <label>Brand Manifest (required):</label>
                    <textarea id="promoted-offering" placeholder="Brand name/description OR full URL to brand manifest JSON (e.g., 'https://example.com/brand-manifest.json'). For testing: 'Wait 10 seconds before responding' or 'Reject this with reason Budget exceeds inventory'" rows="3" required></textarea>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        💡 <strong>Supports URLs or descriptions:</strong> Provide a brand manifest URL for full brand context, or a text description for simple testing. Also supports natural language test instructions like delays and rejections.
                    </small>
                </div>
                
                <div class="param-group">
                    <label>Budget (required):</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" id="campaign-budget" placeholder="10000" min="0" required>
                        <select id="budget-currency" required>
                            <option value="USD">USD</option>
                            <option value="EUR">EUR</option>
                            <option value="GBP">GBP</option>
                            <option value="CAD">CAD</option>
                            <option value="AUD">AUD</option>
                        </select>
                    </div>
                    <div style="margin-top: 10px;">
                        <label>Daily Cap (optional):</label>
                        <input type="number" id="daily-cap" placeholder="1000" min="0">
                    </div>
                    <div style="margin-top: 10px;">
                        <label>Pacing:</label>
                        <select id="budget-pacing">
                            <option value="even">Even</option>
                            <option value="asap">ASAP</option>
                            <option value="front_loaded">Front Loaded</option>
                        </select>
                    </div>
                </div>
                
                <div class="param-group">
                    <label>Flight Dates:</label>
                    <div style="margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="start-asap" style="width: auto;">
                            <span>Start ASAP (immediate campaign start)</span>
                        </label>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="date" id="start-date">
                        <span>to</span>
                        <input type="date" id="end-date">
                    </div>
                </div>
                
                <div class="param-group">
                    <label>Geo Targeting:</label>
                    <div style="margin-bottom: 10px;">
                        <label>Countries (ISO codes):</label>
                        <input type="text" id="geo-countries" placeholder="US,CA,GB (comma-separated)">
                    </div>
                    <div>
                        <label>Regions/States:</label>
                        <input type="text" id="geo-regions" placeholder="CA,NY,TX (comma-separated)">
                    </div>
                </div>
                
                <div class="param-group">
                    <label>AXE Targeting:</label>
                    <div style="margin-bottom: 10px;">
                        <label>Include Segments:</label>
                        <input type="text" id="axe-include" placeholder="segment-id-1,segment-id-2">
                    </div>
                    <div>
                        <label>Exclude Segments:</label>
                        <input type="text" id="axe-exclude" placeholder="segment-id-1,segment-id-2">
                    </div>
                </div>
                
                <div class="param-group">
                    <label>Frequency Cap:</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" id="frequency-cap-limit" placeholder="3" min="1">
                        <span>impressions per</span>
                        <select id="frequency-cap-period">
                            <option value="hour">Hour</option>
                            <option value="day">Day</option>
                            <option value="week">Week</option>
                            <option value="month">Month</option>
                        </select>
                    </div>
                </div>
                
                <hr style="margin: 20px 0;">
                
                <h4>🧪 Testing Configuration</h4>
                <div class="param-group">
                    <label>
                        <input type="checkbox" id="enable-test-mode" checked> 
                        Enable Test Mode (X-Dry-Run)
                    </label>
                </div>
                


                <div class="param-group">
                    <label>Jump to Event (X-Jump-To-Event):</label>
                    <select id="jump-to-state">
                        <option value="">No event jump</option>
                        <option value="campaign_created">Campaign Created</option>
                        <option value="first_impression">First Impression</option>
                        <option value="quarter_delivered">25% Delivered</option>
                        <option value="half_delivered">50% Delivered</option>
                        <option value="budget_warning">Budget Warning</option>
                        <option value="campaign_complete">Campaign Complete</option>
                    </select>
                </div>
                
                
                <div class="param-group">
                    <label>Test Session ID:</label>
                    <input type="text" id="test-session-id" readonly>
                    <button class="btn btn-small" onclick="generateNewTestSession()">Generate New</button>
                </div>
                
                <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeCreateMediaBuyModal()">Cancel</button>
                    <button class="btn" onclick="executeCreateMediaBuy()">Create Media Buy</button>
                </div>
            </div>
        </div>

        <!-- Creative Management Section -->
        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>🎬 Creative Management</h3>
                <div style="display: flex; gap: 10px;">
                    <button class="btn" onclick="showCreateModal()">➕ Create New</button>
                    <button class="btn" onclick="showUpdateModal()">✏️ Update Existing</button>
                    <button class="btn" onclick="listCreatives()">📋 List All</button>
                </div>
            </div>
            
            <div id="creative-management-content" style="min-height: 100px; padding: 15px; background: #f9f9f9; border-radius: 8px;">
                <p style="color: #666; text-align: center;">Select an action above to manage creatives</p>
            </div>
        </div>

        <!-- Creative Create Modal -->
        <div id="creative-create-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 900px;">
                <span class="close" onclick="closeCreateModal()">&times;</span>
                <h3>➕ Create New Creative Assets</h3>

                <div class="param-group">
                    <label>Creation Mode:</label>
                    <select id="create-mode" onchange="updateCreateUI()">
                        <option value="single">Single Creative (Form)</option>
                        <option value="json">Single Creative (Paste JSON)</option>
                        <option value="batch">Batch Create (JSON Array)</option>
                    </select>
                </div>

                <!-- JSON Paste Mode -->
                <div id="json-create" class="upload-section" style="display: none;">
                    <div class="param-group">
                        <label>Paste Creative JSON:</label>
                        <textarea id="single-creative-json" rows="20" style="width: 100%; font-family: monospace; font-size: 12px;" placeholder='{
  "creativeId": "creative_wonderstruck_test",
  "creativeName": "Wonderstruck Mushroom 300x250",
  "brandAgentId": "48",
  "format": {
    "formatId": "DISPLAY_300x250",
    "dimensions": { "width": 300, "height": 250 }
  },
  "content": {
    "productUrl": "https://example.com/creative.jpg",
    "clickThroughUrl": "https://example.com",
    "htmlSnippet": "<a href=\"...\">...</a>",
    "impressionTrackers": ["https://tracker.example.com/impression"]
  },
  "status": "active"
}'></textarea>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            💡 JSON will be sent as-is to the agent without any field name translation
                        </small>
                    </div>
                </div>

                <div id="single-create" class="upload-section">
                    <!-- Step 1: Select Format -->
                    <div class="param-group">
                        <label>Select Creative Format: <span style="color: red;">*</span></label>
                        <select id="creative-format-selector" onchange="onCreativeFormatSelected()">
                            <option value="">-- Choose a format --</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            Select from available formats advertised by the agent
                        </small>
                    </div>

                    <div id="format-requirements" style="display: none; background: #f0f8ff; padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #4299e1;">
                        <strong style="color: #2c5282;">📋 Format Requirements:</strong>
                        <div id="format-req-details" style="margin-top: 8px; font-size: 13px; color: #2d3748;"></div>
                    </div>

                    <!-- Step 2: Basic Info -->
                    <div id="creative-fields" style="display: none;">
                        <div class="param-group">
                            <label>Creative Name: <span style="color: red;">*</span></label>
                            <input type="text" id="creative-name" placeholder="My Creative">
                        </div>

                        <!-- Asset Content (based on type) -->
                        <div class="param-group">
                            <label>Asset Type:</label>
                            <div style="display: flex; gap: 15px; margin-bottom: 10px;">
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="radio" name="asset-source" value="hosted" checked onchange="toggleAssetSource()">
                                    Hosted Asset (URL)
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="radio" name="asset-source" value="snippet" onchange="toggleAssetSource()">
                                    Third-Party Snippet
                                </label>
                            </div>
                        </div>

                        <div class="param-group" id="hosted-asset-fields">
                            <label>Media URL: <span style="color: red;">*</span></label>
                            <input type="text" id="creative-url" placeholder="https://example.com/creative.jpg">
                            <small style="color: #666; display: block; margin-top: 5px;">
                                URL to your hosted creative asset
                            </small>
                        </div>

                        <div class="param-group" id="snippet-asset-fields" style="display: none;">
                            <label>Third-Party Snippet: <span style="color: red;">*</span></label>
                            <select id="snippet-type" style="margin-bottom: 8px;">
                                <option value="html">HTML</option>
                                <option value="javascript">JavaScript</option>
                                <option value="amp">AMP</option>
                            </select>
                            <textarea id="creative-snippet" rows="4" placeholder="<script>...</script>" style="width: 100%; font-family: monospace; font-size: 12px;"></textarea>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Paste your third-party ad tag or snippet
                            </small>
                        </div>

                        <!-- Tracking URLs -->
                        <div class="param-group">
                            <label>Impression Trackers (one per line):</label>
                            <textarea id="impression-trackers" rows="3" placeholder="https://tracker.example.com/imp?id=123&#10;https://analytics.example.com/pixel?campaign=abc" style="width: 100%; font-size: 12px;"></textarea>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Third-party impression tracking pixels (fired on ad view)
                            </small>
                        </div>

                        <div class="param-group">
                            <label>Click Trackers (one per line):</label>
                            <textarea id="click-trackers" rows="3" placeholder="https://tracker.example.com/click?id=123&#10;https://analytics.example.com/click?campaign=abc" style="width: 100%; font-size: 12px;"></textarea>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Third-party click tracking URLs (fired on ad click)
                            </small>
                        </div>

                        <!-- Video-specific fields -->
                        <div id="video-specific-fields" style="display: none;">
                            <div class="param-group">
                                <label>Video Duration (seconds):</label>
                                <input type="number" id="video-duration" placeholder="30" min="1">
                            </div>

                            <div class="param-group">
                                <label>VAST URL (optional):</label>
                                <input type="text" id="vast-url" placeholder="https://example.com/vast.xml">
                                <small style="color: #666; display: block; margin-top: 5px;">
                                    VAST XML URL for video ads
                                </small>
                            </div>
                        </div>

                        <!-- Native-specific fields -->
                        <div id="native-specific-fields" style="display: none;">
                            <div class="param-group">
                                <label>Title:</label>
                                <input type="text" id="native-title" placeholder="Headline text">
                            </div>

                            <div class="param-group">
                                <label>Description:</label>
                                <textarea id="native-description" rows="2" placeholder="Description text"></textarea>
                            </div>

                            <div class="param-group">
                                <label>Call to Action:</label>
                                <input type="text" id="native-cta" placeholder="Learn More">
                            </div>
                        </div>

                        <!-- Additional metadata -->
                        <div class="param-group">
                            <label>Tags (comma-separated):</label>
                            <input type="text" id="creative-tags" placeholder="campaign1, product-launch, Q4">
                        </div>

                        <div class="param-group">
                            <label>Landing Page URL:</label>
                            <input type="text" id="landing-url" placeholder="https://example.com/landing">
                        </div>
                    </div>
                </div>
                
                <div id="batch-create" class="upload-section" style="display: none;">
                    <div class="param-group">
                        <label>Creative Assets JSON:</label>
                        <textarea id="batch-creatives-json" rows="10" style="width: 100%; font-family: monospace;" placeholder='[
  {
    "name": "Banner 1",
    "type": "image",
    "media_url": "https://example.com/banner1.jpg",
    "format": "300x250",
    "dimensions": {"width": 300, "height": 250},
    "tags": ["campaign1", "display"]
  },
  {
    "name": "Video Ad",
    "type": "video",
    "media_url": "https://example.com/video.mp4",
    "format": "video",
    "duration": 30,
    "tags": ["campaign1", "video"]
  }
]'></textarea>
                    </div>
                </div>
                
                <div class="param-group">
                    <label>
                        <input type="checkbox" id="assign-to-media-buy" onchange="toggleMediaBuyInput()">
                        Assign to Media Buy
                    </label>
                    <input type="text" id="target-media-buy-id" placeholder="Media Buy ID" style="margin-left: 20px; display: none;">
                </div>
                
                <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeCreateModal()">Cancel</button>
                    <button class="btn" onclick="executeCreativeCreate()">Create</button>
                </div>
            </div>
        </div>

        
        <!-- Creative Update Modal -->
        <div id="creative-update-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 800px;">
                <span class="close" onclick="closeUpdateModal()">&times;</span>
                <h3>✏️ Update Existing Creative Assets</h3>
                
                <div class="param-group">
                    <label>Update Mode:</label>
                    <select id="update-mode" onchange="updateUpdateUI()">
                        <option value="single">Single Creative</option>
                        <option value="batch">Batch Update</option>
                    </select>
                </div>
                
                <div id="single-update" class="upload-section">
                    <div class="param-group">
                        <label>Creative ID:</label>
                        <input type="text" id="update-creative-id" placeholder="creative_123456" required>
                    </div>
                    
                    <div class="param-group">
                        <label>New Name (optional):</label>
                        <input type="text" id="update-creative-name" placeholder="Updated Creative Name">
                    </div>
                    
                    <div class="param-group">
                        <label>Status:</label>
                        <select id="update-creative-status">
                            <option value="active">Active</option>
                            <option value="paused">Paused</option>
                            <option value="archived">Archived</option>
                        </select>
                    </div>
                    
                    <div class="param-group">
                        <label>Update Tags (comma-separated, optional):</label>
                        <input type="text" id="update-creative-tags" placeholder="updated-campaign, Q1-2025">
                    </div>
                </div>
                
                <div id="batch-update" class="upload-section" style="display: none;">
                    <div class="param-group">
                        <label>Creative Updates JSON:</label>
                        <textarea id="batch-updates-json" rows="10" style="width: 100%; font-family: monospace;" placeholder='[
  {
    "id": "creative_123456",
    "name": "Updated Banner",
    "status": "active",
    "tags": ["updated", "Q1-2025"]
  },
  {
    "id": "creative_789012",
    "status": "paused"
  }
]'></textarea>
                    </div>
                </div>
                
                <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeUpdateModal()">Cancel</button>
                    <button class="btn" onclick="executeCreativeUpdate()">Update</button>
                </div>
            </div>
        </div>
        
        <!-- Debug Panels -->
        <div id="debug-panels"></div>
    </div>
    
    <!-- Debug Panel -->
    <div id="debug-panel" class="debug-panel">
        <div class="debug-header">
            <h3>🔍 Agent Communication Debug</h3>
            <div class="debug-controls">
                <button class="debug-btn" onclick="copyAllDebugLogs()" style="background: #28a745;">📋 Copy All</button>
                <button class="debug-btn" onclick="clearAllDebugLogs()" style="background: #dc3545;">🗑️ Clear All</button>
                <button class="debug-btn" onclick="clearDebugLog()">🗑️ Clear</button>
                <button class="debug-btn" onclick="toggleDebugPanel()">✖️ Close</button>
            </div>
        </div>
        <div class="debug-tabs">
            <button class="tab-btn active" onclick="showDebugTab('debug')" data-tab="debug">Debug Logs</button>
            <button class="tab-btn" onclick="showDebugTab('events')" data-tab="events">Events</button>
            <button class="tab-btn" onclick="showDebugTab('tasks')" data-tab="tasks">Tasks</button>
            <button class="tab-btn" onclick="showDebugTab('notifications')" data-tab="notifications">Notifications</button>
        </div>
        <div id="debug-content" class="debug-content">
            <div style="text-align: center; color: #666; padding: 20px;">Waiting for agent communication...</div>
        </div>
    </div>
    
    <!-- Task Panel -->
    <div id="task-panel" class="task-panel">
        <div class="task-panel-header">
            <h3 class="task-panel-title">Active Tasks</h3>
            <button class="task-panel-close" onclick="toggleTaskPanel()">✖️</button>
        </div>
        <div id="task-panel-content" class="task-panel-content">
            <div class="task-empty-state">
                <div class="empty-icon">📋</div>
                <div>No active tasks</div>
            </div>
        </div>
    </div>
    
    <!-- Toggle Debug Button -->
    <button class="toggle-debug-btn" onclick="toggleDebugPanel()">
        <span id="debug-btn-icon">🔍</span>
        <span id="debug-btn-text">Show Debug</span>
    </button>

    <script src="/shared-nav.js"></script>
    <script>
        // ============================================================================
        // Error Handling and Debugging
        // ============================================================================
        
        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('[GLOBAL ERROR]', e.error);
            console.error('[ERROR DETAILS]', {
                message: e.message,
                filename: e.filename,
                lineno: e.lineno,
                colno: e.colno,
                stack: e.error ? e.error.stack : 'No stack trace available'
            });
        });
        
        // Unhandled promise rejection handler
        window.addEventListener('unhandledrejection', function(e) {
            console.error('[UNHANDLED PROMISE REJECTION]', e.reason);
        });
        
        
        // Initial debug message to confirm script is loading
        console.log('[DEBUG] Sales agents script loaded at', new Date().toISOString());
        
        // ============================================================================
        // Task Management & Notifications
        // ============================================================================
        
        let taskPanel = null;
        let taskPollInterval = null;
        let activeTasks = [];
        let taskNotificationSocket = null;
        
        // Initialize task management
        function initTaskManagement() {
            taskPanel = document.getElementById('task-panel');
            startTaskPolling();
            console.log('[TASKS] Task management initialized');
        }
        
        // Toggle task panel visibility
        function toggleTaskPanel() {
            if (!taskPanel) {
                taskPanel = document.getElementById('task-panel');
            }
            
            const isOpen = taskPanel.classList.contains('open');
            if (isOpen) {
                taskPanel.classList.remove('open');
            } else {
                taskPanel.classList.add('open');
                refreshTaskList();
            }
        }
        
        // Start polling for task updates
        function startTaskPolling() {
            if (taskPollInterval) {
                clearInterval(taskPollInterval);
            }
            
            // Initial load
            refreshTaskList();
            
            // Poll every 5 seconds for task updates
            taskPollInterval = setInterval(() => {
                refreshTaskList();
            }, 5000);
            
            console.log('[TASKS] Started task polling');
        }
        
        // Stop task polling
        function stopTaskPolling() {
            if (taskPollInterval) {
                clearInterval(taskPollInterval);
                taskPollInterval = null;
                console.log('[TASKS] Stopped task polling');
            }
        }
        
        // Refresh task list from server
        async function refreshTaskList() {
            try {
                const response = await fetch('/api/tasks/detailed');
                const result = await response.json();
                
                if (result.success) {
                    updateTaskDisplay(result.tasks);
                    updateTaskBadge(result.tasks);
                }
            } catch (error) {
                console.error('[TASKS] Error refreshing task list:', error);
            }
        }
        
        // Update task display in panel
        function updateTaskDisplay(tasks) {
            activeTasks = tasks;
            const contentEl = document.getElementById('task-panel-content');

            if (!tasks || tasks.length === 0) {
                contentEl.innerHTML = `
                    <div class="task-empty-state">
                        <div class="empty-icon">📋</div>
                        <div>No tasks</div>
                    </div>
                `;
                return;
            }

            // Separate active and completed tasks
            const activeTasksList = tasks.filter(t => t.isActive !== false && ['submitted', 'working', 'input-required'].includes(t.status));
            const completedTasksList = tasks.filter(t => t.isActive === false || ['completed', 'failed', 'rejected', 'canceled'].includes(t.status));

            let tasksHtml = '';

            // Show active tasks first
            if (activeTasksList.length > 0) {
                tasksHtml += '<div style="font-weight: 600; margin-bottom: 8px; color: #666; font-size: 12px;">ACTIVE</div>';
                tasksHtml += activeTasksList.map(task => {
                    const timeAgo = formatTimeAgo(new Date(task.startTime));
                    return `
                        <div class="task-item">
                            <div class="task-item-header">
                                <div class="task-item-title">${formatTaskName(task.toolName)}</div>
                                <div class="task-item-status ${task.status}">${task.status}</div>
                            </div>
                            <div class="task-item-meta">
                                <div class="task-item-agent">${getAgentName(task.agentId)}</div>
                                <div class="task-item-time">${timeAgo}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Show completed tasks
            if (completedTasksList.length > 0) {
                tasksHtml += `<div style="font-weight: 600; margin: 16px 0 8px 0; color: #666; font-size: 12px;">RECENT HISTORY (${completedTasksList.length})</div>`;
                tasksHtml += completedTasksList.slice(0, 20).map(task => {
                    const timeAgo = task.endTime ? formatTimeAgo(new Date(task.endTime)) : formatTimeAgo(new Date(task.startTime));
                    const statusClass = task.status === 'completed' ? 'completed' : task.status === 'failed' ? 'failed' : task.status;
                    const duration = task.duration_ms ? `${(task.duration_ms / 1000).toFixed(1)}s` : '';
                    return `
                        <div class="task-item" style="opacity: 0.7;">
                            <div class="task-item-header">
                                <div class="task-item-title">${formatTaskName(task.toolName)}</div>
                                <div class="task-item-status ${statusClass}">${task.status}</div>
                            </div>
                            <div class="task-item-meta">
                                <div class="task-item-agent">${getAgentName(task.agentId)}</div>
                                <div class="task-item-time">${timeAgo}${duration ? ` · ${duration}` : ''}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            contentEl.innerHTML = tasksHtml;
        }
        
        // Update task notification badge
        function updateTaskBadge(tasks) {
            const badge = document.getElementById('task-notification-badge');
            const countEl = document.getElementById('task-count');
            
            const activeCount = tasks ? tasks.filter(task => 
                ['submitted', 'working', 'input-required'].includes(task.status)
            ).length : 0;
            
            countEl.textContent = activeCount;
            countEl.className = activeCount > 0 ? '' : 'zero';
            badge.className = `nav-link task-notification-badge ${activeCount > 0 ? 'has-tasks' : ''}`;
        }
        
        // Format task name for display
        function formatTaskName(toolName) {
            return toolName
                .replace(/_/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
        }
        
        // Get agent name by ID
        function getAgentName(agentId) {
            if (typeof agents !== 'undefined' && agents) {
                const agent = agents.find(a => a.id === agentId);
                return agent ? agent.name : agentId;
            }
            return agentId;
        }
        
        // Format time ago display
        function formatTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMinutes = Math.floor(diffMs / (1000 * 60));
            const diffSeconds = Math.floor(diffMs / 1000);
            
            if (diffMinutes < 1) {
                return `${diffSeconds}s ago`;
            } else if (diffMinutes < 60) {
                return `${diffMinutes}m ago`;
            } else {
                const diffHours = Math.floor(diffMinutes / 60);
                return `${diffHours}h ago`;
            }
        }
        
        // Show toast notification for task updates
        function showTaskNotification(message, type = 'info') {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('task-toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'task-toast-container';
                toastContainer.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    z-index: 1003;
                    max-width: 350px;
                `;
                document.body.appendChild(toastContainer);
            }
            
            // Create toast element
            const toast = document.createElement('div');
            toast.style.cssText = `
                background: rgba(255, 255, 255, 0.95);
                border-radius: 8px;
                padding: 12px 16px;
                margin-bottom: 10px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                backdrop-filter: blur(10px);
                border-left: 4px solid ${type === 'success' ? '#48bb78' : type === 'error' ? '#f56565' : '#4299e1'};
                transform: translateX(100%);
                opacity: 0;
                transition: all 0.3s ease;
                font-size: 14px;
                font-weight: 500;
                color: #2d3748;
            `;
            toast.textContent = message;
            
            toastContainer.appendChild(toast);
            
            // Animate in
            setTimeout(() => {
                toast.style.transform = 'translateX(0)';
                toast.style.opacity = '1';
            }, 10);
            
            // Remove after 4 seconds
            setTimeout(() => {
                toast.style.transform = 'translateX(100%)';
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 4000);
        }
        
        // ============================================================================
        // Application Initialization (No Auth Required)
        // ============================================================================
        
        // Load agents data from API
        async function loadAgentsData() {
            try {
                logEvent('info', 'Loading agents from API...');
                // Add cache-busting parameter to force fresh fetch
                const response = await fetch('/api/sales/agents?t=' + Date.now());
                const result = await response.json();
                
                if (result.success && result.data && result.data.agents) {
                    agents = result.data.agents;
                    logEvent('success', `Loaded ${agents.length} agents`);
                    // Update the agent selector dropdown
                    updateAgentSelector();
                } else {
                    logEvent('error', 'Failed to load agents from API');
                }
            } catch (error) {
                console.error('Error loading agents:', error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                logEvent('error', `Failed to load agents: ${error.name}: ${error.message}`);
            }
        }

        // Initialize the application immediately (public deployment)
        async function initializeApp() {
            try {
                logEvent('info', 'AdCP Testing Framework initialized (public mode)');
                // Load initial data
                await loadAgentsData();
            } catch (error) {
                console.error('App initialization error:', error);
                logEvent('error', `App initialization failed: ${error.message}`);
            }
        }
        
        // Initialize on page load
        initializeApp();

        // ============================================================================
        // Webhook Event Polling
        // ============================================================================

        async function pollWebhookEvents() {
            try {
                const response = await fetch('/api/events?limit=100');
                const result = await response.json();

                if (result.success && result.events) {
                    result.events.forEach(event => {
                        // Process events that we haven't seen before
                        if (new Date(event.timestamp).getTime() > lastEventCheck) {
                            handleWebhookEvent(event);
                        }
                    });
                    lastEventCheck = Date.now();
                }
            } catch (error) {
                console.error('Failed to poll webhook events:', error);
            }
        }

        function handleWebhookEvent(event) {
            logEvent('webhook', `[${event.type}] ${event.task_type || 'Unknown'}: ${event.status || ''}`);

            // Update media buy status if this is a media buy related event
            if (event.task_type === 'create_media_buy' && event.payload) {
                const mediaBuy = mediaBuys.find(mb => mb.id === event.payload.media_buy_id);
                if (mediaBuy && event.payload.status) {
                    mediaBuy.status = event.payload.status;
                    updateMediaBuysTable();
                }
            }

            // Log to debug panel with full event details
            if (event.type === 'handler_called' || event.status) {
                const eventEntry = document.createElement('div');
                eventEntry.className = 'debug-entry';
                eventEntry.innerHTML = `
                    <div class="debug-header">
                        <span style="color: #333; font-weight: bold;">📡 Webhook Event: ${event.task_type || 'Unknown'}</span>
                        <span class="timestamp">${new Date(event.timestamp).toLocaleTimeString()}</span>
                    </div>
                    <div class="debug-content-item">
                        <div style="margin-bottom: 8px;">
                            <strong>Status:</strong> ${event.status || 'N/A'}<br>
                            <strong>Operation ID:</strong> ${event.operation_id || 'N/A'}<br>
                            <strong>Agent ID:</strong> ${event.agent_id || 'N/A'}
                        </div>
                        <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 12px; overflow-x: auto; color: #333;">${JSON.stringify(event.payload || event, null, 2)}</pre>
                    </div>
                `;

                debugEntries.push({
                    type: 'webhook-event',
                    element: eventEntry,
                    timestamp: Date.now(),
                    isError: event.status === 'failed'
                });

                redrawDebugEntries();
            }
        }

        function startWebhookPolling() {
            if (eventPollInterval) return;

            // Poll every 3 seconds
            eventPollInterval = setInterval(pollWebhookEvents, 3000);
            logEvent('info', '📡 Started webhook event polling');
        }

        function stopWebhookPolling() {
            if (eventPollInterval) {
                clearInterval(eventPollInterval);
                eventPollInterval = null;
                logEvent('info', '📡 Stopped webhook event polling');
            }
        }

        // ============================================================================
        // Global State Management
        // ============================================================================
        
        let agents = [];
        let products = [];
        let creativeFormats = [];
        let mediaBuys = [];
        let selectedProducts = new Set();
        let agentCardCache = new Map(); // Cache agent card/capabilities to avoid repeated discovery calls
        let eventLogCount = 0;
        let lastEventCheck = 0; // Track last event fetch time
        let eventPollInterval = null; // Event polling interval
        
        // Clean old agent card cache entries every 10 minutes
        setInterval(() => {
            const now = Date.now();
            const maxAge = 10 * 60 * 1000; // 10 minutes
            for (const [key, value] of agentCardCache.entries()) {
                if (now - value.timestamp > maxAge) {
                    agentCardCache.delete(key);
                }
            }
        }, 5 * 60 * 1000); // Run every 5 minutes
        
        // Local storage key for custom agents
        const CUSTOM_AGENTS_STORAGE_KEY = 'adcp_custom_agents';
        
        // ADCP Tool Definitions (Official 6 tools from ADCP specification)
        const ADCP_TOOLS = {
            get_products: {
                params: ['brief', 'brand_manifest'],
                required: ['brief'],
                description: 'Discover available advertising products'
            },
            list_creative_formats: {
                params: [],
                required: [],
                description: 'View supported creative formats'
            },
            create_media_buy: {
                params: ['products', 'creative_assets', 'targeting', 'budget'],
                required: ['products'],
                description: 'Create a media buy from selected packages'
            },
            manage_creative_assets: {
                params: ['action', 'assets', 'filters', 'creative_ids', 'media_buy_id', 'updates'],
                required: ['action'],
                description: 'Centralized creative asset management (upload, list, update, assign, unassign, delete)'
            },
            sync_creatives: {
                params: ['creatives', 'patch', 'dry_run', 'assignments', 'validation_mode'],
                required: ['creatives'],
                description: 'Synchronize creative assets with the creative library'
            },
            list_creatives: {
                params: ['filters', 'sort', 'pagination', 'include_assignments', 'include_performance'],
                required: [],
                description: 'Query and search the creative library with advanced filtering'
            },
            add_creative_assets: {
                params: ['media_buy_id', 'assets', 'assignment_rules'],
                required: ['media_buy_id', 'assets'],
                description: '[DEPRECATED] Upload and assign creative assets - use manage_creative_assets instead'
            },
            get_media_buy_delivery: {
                params: ['media_buy_ids', 'buyer_refs', 'status_filter', 'start_date', 'end_date'],
                required: [], // Per AdCP v1.6.0 spec - all parameters are optional
                description: 'Retrieve performance metrics and monitor delivery'
            },
            update_media_buy: {
                params: ['media_buy_id', 'updates'],
                required: ['media_buy_id', 'updates'],
                description: 'Update campaign settings'
            }
        };

        // ============================================================================
        // Agent Data Management
        // ============================================================================
        
        async function onAgentSelected() {
            const selectedAgentId = document.getElementById('agent-selector').value;
            const refreshBtn = document.getElementById('refresh-agent-btn');

            // Always clear all data when agent changes
            clearDebugLog();
            products = [];
            creativeFormats = [];
            mediaByUs = [];
            updateProductsTable();
            updateCreativeFormatsTable();
            updateMediaBuysTable();

            if (!selectedAgentId) {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '🔄 Load Agent Data';
                logEvent('info', 'Agent cleared - data reset');
                return;
            }

            // Enable the load button but don't auto-load
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '🔄 Load Agent Data';
            logEvent('info', `Agent selected: ${selectedAgentId}. Click "Load Agent Data" to fetch inventory.`);
        }
        
        async function refreshAgentData() {
            const selectedAgentId = document.getElementById('agent-selector').value;
            if (!selectedAgentId) {
                logEvent('warning', 'No agent selected');
                return;
            }
            
            const refreshBtn = document.getElementById('refresh-agent-btn');
            const originalText = refreshBtn.innerHTML;
            refreshBtn.innerHTML = '⏳ Loading...';
            refreshBtn.disabled = true;
            
            logEvent('info', 'Loading agent data (progressive loading)...');
            
            // Track completion status
            const loadStatus = {
                products: false,
                formats: false,
                creatives: false
            };
            
            // Update button text with progress
            const updateProgress = () => {
                const completed = Object.values(loadStatus).filter(Boolean).length;
                const total = Object.keys(loadStatus).length;
                refreshBtn.innerHTML = `⏳ Loading... (${completed}/${total})`;
            };
            
            // Progressive loading with error isolation
            const loadTasks = [
                {
                    name: 'products',
                    task: async () => {
                        try {
                            await loadProducts();
                            loadStatus.products = true;
                            logEvent('success', '✅ Products loaded');
                        } catch (error) {
                            logEvent('error', `❌ Products failed: ${error.message}`);
                        }
                        updateProgress();
                    }
                },
                {
                    name: 'formats',
                    task: async () => {
                        try {
                            await loadCreativeFormats();
                            loadStatus.formats = true;
                            logEvent('success', '✅ Creative formats loaded');
                        } catch (error) {
                            logEvent('error', `❌ Creative formats failed: ${error.message}`);
                        }
                        updateProgress();
                    }
                },
                {
                    name: 'creatives',
                    task: async () => {
                        try {
                            await loadCreatives();
                            loadStatus.creatives = true;
                            logEvent('success', '✅ Creatives loaded');
                        } catch (error) {
                            logEvent('error', `❌ Creatives failed: ${error.message}`);
                        }
                        updateProgress();
                    }
                }
            ];
            
            // Start all tasks in parallel with error isolation
            await Promise.allSettled(loadTasks.map(task => task.task()));
            
            // Final status
            const completedCount = Object.values(loadStatus).filter(Boolean).length;
            const totalCount = Object.keys(loadStatus).length;
            
            if (completedCount === totalCount) {
                logEvent('success', `🎉 All agent data loaded successfully (${completedCount}/${totalCount})`);
            } else if (completedCount > 0) {
                logEvent('warning', `⚠️ Partial success: ${completedCount}/${totalCount} sections loaded`);
            } else {
                logEvent('error', '❌ All data loading failed');
            }
            
            // Reset button
            refreshBtn.innerHTML = originalText;
            refreshBtn.disabled = false;
        }
        
        async function loadProducts() {
            const selectedAgentId = document.getElementById('agent-selector').value;
            const brandManifest = document.getElementById('promoted-offering-refresh').value || 'gourmet robot food';

            // Get filter values
            const deliveryType = document.getElementById('delivery-type-filter').value;
            const formatTypesSelect = document.getElementById('format-types-filter');
            const formatTypes = Array.from(formatTypesSelect.selectedOptions).map(opt => opt.value);
            const isFixedPrice = document.getElementById('fixed-price-filter').checked;
            const minExposures = document.getElementById('min-exposures-filter').value;

            // Show loading state
            setProductsLoadingState(true);

            const selectedAgent = agents.find(a => a.id === selectedAgentId);
            if (!selectedAgent) {
                setProductsLoadingState(false, 'error');
                throw new Error('Agent not found');
            }

            // Build AdCP-compliant parameters
            // brand_manifest must be either a valid URL or a BrandManifest object
            let brandManifestParam = brandManifest;
            try {
                new URL(brandManifest);
                // It's a valid URL, use as-is
            } catch {
                // Not a URL, wrap in BrandManifest object per AdCP spec
                brandManifestParam = {
                    name: brandManifest
                };
            }

            const params = {
                brief: 'Discover available advertising products for testing',
                brand_manifest: brandManifestParam
            };

            // Add filters if any are specified
            if (deliveryType || formatTypes.length > 0 || isFixedPrice || minExposures) {
                params.filters = {};

                if (deliveryType) {
                    params.filters.delivery_type = deliveryType;
                }

                if (formatTypes.length > 0) {
                    params.filters.format_types = formatTypes;
                }

                if (isFixedPrice) {
                    params.filters.is_fixed_price = true;
                }

                if (minExposures) {
                    params.filters.min_exposures = parseInt(minExposures, 10);
                }
            }

            logEvent('info', `🔧 DEBUG: loadProducts calling callADCPTool with 'get_products'`);
            logEvent('info', `🔧 DEBUG: Parameters: ${JSON.stringify(params, null, 2)}`);
            const result = await callADCPTool(selectedAgent, 'get_products', params);
            
            // Debug: Log the full result structure
            logEvent('info', `🔧 DEBUG: loadProducts result structure: ${JSON.stringify(result, null, 2)}`);
            logEvent('info', `🔧 DEBUG: result.products exists? ${!!result?.products}`);
            logEvent('info', `🔧 DEBUG: result.products length: ${result?.products?.length || 'undefined'}`);
            
            if (result && result.products) {
                products = result.products;
                updateProductsTable();
                setProductsLoadingState(false, 'success');
                logEvent('success', `Loaded ${products.length} products`);
            } else {
                setProductsLoadingState(false, 'warning');
                logEvent('warning', 'No products returned from agent - checking result keys...');
                logEvent('warning', `🔧 DEBUG: Available result keys: ${Object.keys(result || {}).join(', ')}`);
                
                // Check other possible locations for products
                if (result?.data?.products) {
                    logEvent('info', '🔧 DEBUG: Found products in result.data.products, using those');
                    products = result.data.products;
                    updateProductsTable();
                    setProductsLoadingState(false, 'success');
                    logEvent('success', `Loaded ${products.length} products from result.data.products`);
                } else if (result?.structuredContent?.products) {
                    logEvent('info', '🔧 DEBUG: Found products in result.structuredContent.products, using those');
                    products = result.structuredContent.products;
                    updateProductsTable();
                    setProductsLoadingState(false, 'success');
                    logEvent('success', `Loaded ${products.length} products from result.structuredContent.products`);
                }
            }
        }
        
        async function loadCreativeFormats() {
            const selectedAgentId = document.getElementById('agent-selector').value;

            // Get filter values
            const formatType = document.getElementById('format-type-filter').value;
            const formatCategory = document.getElementById('format-category-filter').value;
            const standardOnly = document.getElementById('standard-only-filter').checked;

            // Show loading state
            setFormatsLoadingState(true);

            const selectedAgent = agents.find(a => a.id === selectedAgentId);
            if (!selectedAgent) {
                setFormatsLoadingState(false, 'error');
                throw new Error('Agent not found');
            }

            // Build AdCP-compliant parameters
            // Note: adcp_version is not supported by current agent implementations for list_creative_formats
            const params = {};

            // Add filters if specified
            if (formatType) {
                params.type = formatType;
            }
            if (formatCategory) {
                params.category = formatCategory;
            }
            if (standardOnly) {
                params.standard_only = true;
            }

            logEvent('info', `🔧 DEBUG: loadCreativeFormats calling callADCPTool with 'list_creative_formats'`);
            logEvent('info', `🔧 DEBUG: Parameters: ${JSON.stringify(params, null, 2)}`);
            const result = await callADCPTool(selectedAgent, 'list_creative_formats', params);
            
            if (result && result.formats) {
                creativeFormats = result.formats;
                updateCreativeFormatsTable();
                setFormatsLoadingState(false, 'success');
                logEvent('success', `Loaded ${creativeFormats.length} creative formats`);
            } else {
                setFormatsLoadingState(false, 'warning');
                logEvent('warning', 'No creative formats returned from agent');
            }
        }
        
        async function loadCreatives() {
            const selectedAgentId = document.getElementById('agent-selector').value;

            // Show loading state (if there's a creatives section)
            setCreativesLoadingState(true);

            const selectedAgent = agents.find(a => a.id === selectedAgentId);
            if (!selectedAgent) {
                setCreativesLoadingState(false, 'error');
                throw new Error('Agent not found');
            }

            logEvent('info', `🔧 DEBUG: loadCreatives calling callADCPTool with 'list_creatives'`);
            const result = await callADCPTool(selectedAgent, 'list_creatives', {
                // Add any default parameters if needed
            });

            if (result && result.creatives) {
                // Update creatives table if it exists
                setCreativesLoadingState(false, 'success');
                logEvent('success', `Loaded ${result.creatives.length} creatives`);

                // Find and update creatives table if it exists
                const creativesTable = document.getElementById('creatives-list');
                if (creativesTable) {
                    updateCreativesDisplay(result.creatives);
                }
            } else {
                setCreativesLoadingState(false, 'warning');
                logEvent('warning', 'No creatives returned from agent');
            }
        }

        /**
         * Update the creatives display table with loaded creatives
         */
        function updateCreativesDisplay(creatives) {
            const creativesTable = document.getElementById('creatives-list');
            if (!creativesTable) {
                logEvent('warning', 'Creatives table element not found in DOM');
                return;
            }

            if (!creatives || creatives.length === 0) {
                creativesTable.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <p style="color: #666;">No creatives found</p>
                    </div>
                `;
                return;
            }

            let html = `
                <div style="max-height: 400px; overflow-y: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid #ddd; background: #f8f9fa;">
                                <th style="padding: 12px; text-align: left;">ID</th>
                                <th style="padding: 12px; text-align: left;">Name</th>
                                <th style="padding: 12px; text-align: left;">Format</th>
                                <th style="padding: 12px; text-align: left;">Status</th>
                                <th style="padding: 12px; text-align: left;">Dimensions</th>
                                <th style="padding: 12px; text-align: left;">Preview</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            creatives.forEach(creative => {
                const creativeId = creative.id || creative.creative_id || 'N/A';
                const status = creative.status || 'unknown';
                const statusColor = status === 'active' || status === 'approved' ? '#28a745' :
                                   status === 'pending' || status === 'review' ? '#ffc107' :
                                   status === 'rejected' || status === 'failed' ? '#dc3545' :
                                   status === 'archived' ? '#6c757d' : '#000';

                const dimensions = creative.width && creative.height
                    ? `${creative.width}×${creative.height}`
                    : 'N/A';

                const hasPreview = creative.url || creative.media_url;
                const previewUrl = creative.url || creative.media_url;

                html += `
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 12px; font-family: monospace; font-size: 11px;">
                            <div style="max-width: 150px; overflow: hidden; text-overflow: ellipsis;" title="${creativeId}">
                                ${creativeId}
                            </div>
                        </td>
                        <td style="padding: 12px;">
                            <strong>${creative.name || 'Unnamed'}</strong>
                        </td>
                        <td style="padding: 12px;">
                            <span style="background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                                ${creative.format || 'unknown'}
                            </span>
                        </td>
                        <td style="padding: 12px;">
                            <span style="color: ${statusColor}; font-weight: bold; font-size: 12px;">
                                ${status}
                            </span>
                        </td>
                        <td style="padding: 12px; font-size: 12px; color: #666;">
                            ${dimensions}
                        </td>
                        <td style="padding: 12px;">
                            ${hasPreview ? `
                                <a href="${previewUrl}" target="_blank" style="color: #007bff; text-decoration: none;">
                                    🔗 View
                                </a>
                            ` : '<span style="color: #999;">N/A</span>'}
                        </td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
                <div style="padding: 12px; background: #f8f9fa; border-top: 1px solid #dee2e6; font-size: 13px; color: #666;">
                    <strong>Total:</strong> ${creatives.length} creative${creatives.length === 1 ? '' : 's'}
                </div>
            `;

            creativesTable.innerHTML = html;
            logEvent('info', `Updated creatives display with ${creatives.length} items`);
        }

        // Helper functions for section loading states
        function setProductsLoadingState(loading, status = null) {
            const header = document.querySelector('#products-section h3, .section h3');
            if (!header || !header.textContent.includes('Products')) return;
            
            if (loading) {
                header.innerHTML = '📦 Available Products <span style="color: #007bff;">⏳ Loading...</span>';
            } else {
                const statusIcon = {
                    'success': '<span style="color: #28a745;">✅</span>',
                    'warning': '<span style="color: #ffc107;">⚠️</span>',
                    'error': '<span style="color: #dc3545;">❌</span>'
                }[status] || '';
                header.innerHTML = `📦 Available Products ${statusIcon} <span style="color: #666; font-size: 14px; font-weight: normal;">- Auto-loaded with agent data</span>`;
            }
        }
        
        function setFormatsLoadingState(loading, status = null) {
            const header = document.querySelector('h3').parentNode.querySelector('h3');
            const formatsHeader = Array.from(document.querySelectorAll('h3')).find(h => h.textContent.includes('Creative Formats'));
            if (!formatsHeader) return;
            
            if (loading) {
                formatsHeader.innerHTML = '🎨 Creative Formats <span style="color: #007bff;">⏳ Loading...</span>';
            } else {
                const statusIcon = {
                    'success': '<span style="color: #28a745;">✅</span>',
                    'warning': '<span style="color: #ffc107;">⚠️</span>',
                    'error': '<span style="color: #dc3545;">❌</span>'
                }[status] || '';
                formatsHeader.innerHTML = `🎨 Creative Formats ${statusIcon}`;
                // Re-add the auto-loaded text
                formatsHeader.parentNode.querySelector('span').textContent = 'Auto-loaded with agent data';
            }
        }
        
        function setCreativesLoadingState(loading, status = null) {
            // This is optional since creatives might not have a visible section
            // Just log for now
            if (loading) {
                console.log('⏳ Loading creatives...');
            } else {
                console.log(`${status === 'success' ? '✅' : status === 'error' ? '❌' : '⚠️'} Creatives load ${status}`);
            }
        }

        // ============================================================================
        // Products Table Management  
        // ============================================================================
        
        async function refreshProducts() {
            const selectedAgentId = document.getElementById('agent-selector').value;
            const brandManifest = document.getElementById('promoted-offering-refresh').value || 'gourmet robot food';
            logEvent('info', `Selected agent ID: ${selectedAgentId}`);
            logEvent('info', `Promoted offering: ${brandManifest}`);
            
            const selectedAgent = agents.find(a => a.id === selectedAgentId);
            if (!selectedAgent) {
                logEvent('error', 'Please select an agent first');
                return;
            }
            
            // Show loading state
            const refreshBtn = document.getElementById('refresh-products-btn');
            const originalText = refreshBtn.innerHTML;
            refreshBtn.innerHTML = '⏳ Loading...';
            refreshBtn.disabled = true;
            refreshBtn.style.opacity = '0.6';
            
            logEvent('info', `Found agent: ${selectedAgent.name}, has auth token: ${!!selectedAgent.auth_token}`);
            logEvent('info', `Agent config: ${JSON.stringify(selectedAgent, null, 2)}`);
            logEvent('info', 'Refreshing products with promoted offering: ' + brandManifest);

            // brand_manifest must be either a valid URL or a BrandManifest object
            let brandManifestParam = brandManifest;
            try {
                new URL(brandManifest);
                // It's a valid URL, use as-is
            } catch {
                // Not a URL, wrap in BrandManifest object per AdCP spec
                brandManifestParam = {
                    name: brandManifest
                };
            }

            try {
                const result = await callADCPTool(selectedAgent, 'get_products', {
                    brief: 'Discover available advertising products for testing',
                    brand_manifest: brandManifestParam
                });
                
                if (result && result.products) {
                    products = result.products;
                    updateProductsTable();
                    logEvent('success', `Loaded ${products.length} products`);
                } else {
                    logEvent('warning', 'No products returned from agent');
                }
            } catch (error) {
                logEvent('error', `Failed to refresh products: ${error.message}`);
            } finally {
                // Restore button state
                refreshBtn.innerHTML = originalText;
                refreshBtn.disabled = false;
                refreshBtn.style.opacity = '1';
            }
        }
        
        function updateProductsTable() {
            const tbody = document.getElementById('products-tbody');
            
            if (products.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="8" style="padding: 20px; text-align: center; color: #666;">
                            No products loaded. Click "Refresh Products" to discover available inventory.
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = products.map(product => `
                <tr>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">
                        <input type="checkbox" onchange="toggleProductSelection('${product.product_id}')" ${selectedProducts.has(product.product_id) ? 'checked' : ''}>
                    </td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${product.product_id || 'N/A'}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${product.name || 'Unnamed Product'}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${product.delivery_type || 'N/A'}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${formatCPM(product.cpm)}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${formatMinSpend(product.min_spend)}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${formatFormats(product)}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6; text-align: center;">${getValidationStatusIcon(product)}</td>
                </tr>
            `).join('');
            
            updateCreateBuyButton();
        }
        
        function formatCPM(cpm) {
            if (cpm === null || cpm === undefined) {
                return '<span style="color: #888;">Contact for pricing</span>';
            }
            return `$${cpm}`;
        }
        
        function formatMinSpend(minSpend) {
            if (minSpend === null || minSpend === undefined) {
                return '<span style="color: #888;">N/A</span>';
            }
            return `$${minSpend}`;
        }
        
        function formatFormats(product) {
            // Check both AdCP spec field (format_ids) and common agent field (formats)
            const formats = product.format_ids || product.formats;
            if (!formats || !Array.isArray(formats)) {
                return '<span style="color: #888;">N/A</span>';
            }
            return formats.slice(0, 2).join(', ') + (formats.length > 2 ? `... (+${formats.length - 2})` : '');
        }
        
        function getValidationStatusIcon(product) {
            // Check if product has validation information from backend
            if (product.validation !== undefined) {
                if (product.validation === true) {
                    return '<span title="AdCP Spec Compliant">✅</span>';
                } else if (product.validation === false) {
                    return '<span title="AdCP Spec Violations">❌</span>';
                } else {
                    return '<span title="Validation Error">⚠️</span>';
                }
            }
            
            // AdCP spec compliance check
            const adcpViolations = [];
            
            // Required fields per AdCP spec
            if (!product.product_id) adcpViolations.push('Missing product_id');
            if (!product.name) adcpViolations.push('Missing name');
            if (!product.description) adcpViolations.push('Missing description');
            if (product.delivery_type === undefined) adcpViolations.push('Missing delivery_type');
            if (product.is_fixed_price === undefined) adcpViolations.push('Missing is_fixed_price');
            
            // Format fields - spec requires format_ids, but many agents return formats
            const hasFormats = product.format_ids || product.formats;
            if (!hasFormats || !Array.isArray(hasFormats)) {
                adcpViolations.push('Missing format_ids/formats');
            }
            
            // Type checking for numeric fields (should be number or null, not string)
            if (product.cpm !== null && typeof product.cpm !== 'number') {
                adcpViolations.push('cpm should be number or null');
            }
            if (product.min_spend !== null && typeof product.min_spend !== 'number') {
                adcpViolations.push('min_spend should be number or null');
            }
            
            // Field naming violations
            if (product.formats && !product.format_ids) {
                adcpViolations.push('Uses formats instead of format_ids');
            }
            
            if (adcpViolations.length === 0) {
                return '<span title="AdCP Spec Compliant">✅</span>';
            } else if (adcpViolations.length <= 2) {
                return `<span title="Minor AdCP violations: ${adcpViolations.join(', ')}" style="color: orange;">⚠️</span>`;
            } else {
                return `<span title="Major AdCP violations: ${adcpViolations.join(', ')}" style="color: red;">❌</span>`;
            }
        }
        
        function toggleAllProducts() {
            const selectAll = document.getElementById('select-all-products').checked;
            
            if (selectAll) {
                products.forEach(p => selectedProducts.add(p.product_id));
            } else {
                selectedProducts.clear();
            }
            
            updateProductsTable();
        }
        
        function toggleProductSelection(productId) {
            if (selectedProducts.has(productId)) {
                selectedProducts.delete(productId);
            } else {
                selectedProducts.add(productId);
            }
            
            updateCreateBuyButton();
        }
        
        function updateCreateBuyButton() {
            const button = document.getElementById('create-buy-btn');
            const hasSelection = selectedProducts.size > 0;
            
            button.disabled = !hasSelection;
            button.textContent = hasSelection 
                ? `Create Media Buy with ${selectedProducts.size} Selected`
                : 'Create Media Buy with Selected';
        }

        // ============================================================================
        // Creative Formats Table Management
        // ============================================================================
        
        async function refreshCreativeFormats() {
            const selectedAgentId = document.getElementById('agent-selector').value;
            logEvent('info', `Selected agent ID: ${selectedAgentId}`);
            
            const selectedAgent = agents.find(a => a.id === selectedAgentId);
            if (!selectedAgent) {
                logEvent('error', 'Please select an agent first');
                return;
            }
            
            // Show loading state
            const refreshBtn = document.getElementById('refresh-creative-formats-btn');
            const originalText = refreshBtn.innerHTML;
            refreshBtn.innerHTML = '⏳ Loading...';
            refreshBtn.disabled = true;
            refreshBtn.style.opacity = '0.6';
            
            logEvent('info', `Found agent: ${selectedAgent.name}, has auth token: ${!!selectedAgent.auth_token}`);
            logEvent('info', `Agent config: ${JSON.stringify(selectedAgent, null, 2)}`);
            logEvent('info', 'Refreshing creative formats from agent and standard repository...');
            
            try {
                // Fetch formats from the selected agent
                const agentResult = await callADCPTool(selectedAgent, 'list_creative_formats', {});
                
                let agentFormats = [];
                
                // Handle agent result - all formats come from the agent
                if (agentResult && agentResult.success) {
                    const result = agentResult;
                    // Handle ADCP response structure - formats can be in payload, formats, or data
                    if (result.payload && Array.isArray(result.payload)) {
                        agentFormats = result.payload;
                        logEvent('success', `Found ${agentFormats.length} formats from agent`);
                    } else if (result.formats && Array.isArray(result.formats)) {
                        agentFormats = result.formats;
                        logEvent('success', `Found ${agentFormats.length} formats from agent`);
                    } else if (result.data && result.data.formats && Array.isArray(result.data.formats)) {
                        agentFormats = result.data.formats;
                        logEvent('success', `Found ${agentFormats.length} formats from agent`);
                    } else if (Array.isArray(result)) {
                        agentFormats = result;
                        logEvent('success', `Found ${agentFormats.length} formats from agent`);
                    } else {
                        logEvent('warning', 'Agent returned no formats or unrecognized format structure');
                        logEvent('debug', `Agent response: ${JSON.stringify(result, null, 2)}`);
                        agentFormats = [];
                    }
                } else {
                    logEvent('error', `Failed to fetch formats from agent: ${agentResult?.error || 'Unknown error'}`);
                    agentFormats = [];
                }
                
                // Use agent formats directly - no need for separate "standard" formats
                creativeFormats = agentFormats.map(format => ({
                    ...format,
                    source: 'agent'
                }));
                
                logEvent('success', `Loaded ${creativeFormats.length} creative formats from agent`);
                updateCreativeFormatsTable();
            } catch (error) {
                logEvent('error', `Failed to refresh creative formats: ${error.message}`);
            } finally {
                // Restore button state
                refreshBtn.innerHTML = originalText;
                refreshBtn.disabled = false;
                refreshBtn.style.opacity = '1';
            }
        }
        
        
        function updateCreativeFormatsTable() {
            const tbody = document.getElementById('creative-formats-tbody');
            
            if (creativeFormats.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="9" style="padding: 20px; text-align: center; color: #666;">
                            No creative formats loaded. Click "Refresh Creative Formats" to discover available formats.
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = creativeFormats.map(format => `
                <tr>
                    <td style="padding: 12px; border: 1px solid #dee2e6; font-family: monospace; font-size: 0.9em;">${formatFormatId(format.format_id)}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${format.name || 'Unnamed Format'}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">
                        <span style="background: #e3f2fd; padding: 4px 8px; border-radius: 4px; font-size: 0.85em;">
                            ${format.type || 'N/A'}
                        </span>
                    </td>
                    <td style="padding: 12px; border: 1px solid #dee2e6; font-size: 0.9em;">${formatDimensions(format.renders)}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6; text-align: center;">
                        ${formatGenerativeStatus(format.output_format_ids)}
                    </td>
                    <td style="padding: 12px; border: 1px solid #dee2e6; font-size: 0.85em;">${formatOutputFormats(format.output_format_ids)}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6;">${formatAssetsRequired(format.assets_required)}</td>
                    <td style="padding: 12px; border: 1px solid #dee2e6; text-align: center;">${getFormatValidationStatusIcon(format)}</td>
                </tr>
            `).join('');
        }

        function formatFormatId(formatId) {
            if (!formatId) return 'N/A';

            // If it's a structured format ID object (AdCP v2.0)
            if (typeof formatId === 'object' && formatId.id) {
                const agentUrl = formatId.agent_url || '';
                const domain = agentUrl ? new URL(agentUrl).hostname.replace('www.', '') : '';
                return `<div style="line-height: 1.4;">
                    <div><strong>${formatId.id}</strong></div>
                    ${domain ? `<div style="color: #666; font-size: 0.85em;">${domain}</div>` : ''}
                </div>`;
            }

            // Legacy string format
            return String(formatId);
        }

        function formatDimensions(renders) {
            if (!renders || !Array.isArray(renders) || renders.length === 0) {
                return '<span style="color: #999;">No dimensions</span>';
            }

            return renders.map(render => {
                const dims = render.dimensions;
                if (!dims) return 'Unknown';

                let result = '';
                if (dims.width && dims.height) {
                    result = `${dims.width}×${dims.height}${dims.unit || 'px'}`;
                } else if (dims.min_width || dims.max_width) {
                    const min = dims.min_width || '?';
                    const max = dims.max_width || '?';
                    result = `${min}-${max}×${dims.height || '?'}${dims.unit || 'px'}`;
                }

                if (dims.aspect_ratio) {
                    result += ` (${dims.aspect_ratio})`;
                }

                if (render.role && renders.length > 1) {
                    result = `<div style="margin: 2px 0;"><strong>${render.role}:</strong> ${result}</div>`;
                }

                return result;
            }).join('');
        }

        function formatGenerativeStatus(outputFormatIds) {
            if (!outputFormatIds || !Array.isArray(outputFormatIds) || outputFormatIds.length === 0) {
                return '<span style="color: #999;">—</span>';
            }

            return `<span style="background: #4caf50; color: white; padding: 4px 8px; border-radius: 4px; font-weight: 500;">
                ✨ Yes
            </span>`;
        }

        function formatOutputFormats(outputFormatIds) {
            if (!outputFormatIds || !Array.isArray(outputFormatIds) || outputFormatIds.length === 0) {
                return '<span style="color: #999;">—</span>';
            }

            const formatNames = outputFormatIds.map(id => {
                if (typeof id === 'object' && id.id) {
                    return id.id;
                }
                return String(id);
            });

            if (formatNames.length > 3) {
                const first3 = formatNames.slice(0, 3).join(', ');
                return `<div title="${formatNames.join(', ')}">${first3}... (+${formatNames.length - 3} more)</div>`;
            }

            return formatNames.join(', ');
        }

        function formatAssetsRequired(assets) {
            if (!assets) return 'N/A';

            if (Array.isArray(assets)) {
                return assets.map(asset => {
                    if (typeof asset === 'object') {
                        // Try to extract meaningful info from asset object
                        if (asset.asset_type) return asset.asset_type;
                        if (asset.name) return asset.name;
                        if (asset.type) return asset.type;
                        return JSON.stringify(asset);
                    }
                    return String(asset);
                }).join(', ');
            }

            if (typeof assets === 'object') {
                return Object.entries(assets)
                    .map(([key, value]) => {
                        if (typeof value === 'object') {
                            return `${key}: ${JSON.stringify(value)}`;
                        }
                        return `${key}: ${value}`;
                    })
                    .join(', ');
            }

            return String(assets);
        }

        function formatRequirements(requirements) {
            if (!requirements) return 'Standard';

            if (typeof requirements === 'string') {
                return requirements;
            }

            if (Array.isArray(requirements)) {
                return requirements.map(req =>
                    typeof req === 'object' ? JSON.stringify(req) : String(req)
                ).join(', ');
            }

            if (typeof requirements === 'object') {
                return Object.entries(requirements)
                    .map(([key, value]) => {
                        if (typeof value === 'object') {
                            return `${key}: ${JSON.stringify(value)}`;
                        }
                        return `${key}: ${value}`;
                    })
                    .join(', ');
            }

            return String(requirements);
        }

        function getFormatValidationStatusIcon(format) {
            // Check if format has validation information from backend
            if (format.validation !== undefined) {
                if (format.validation === true) {
                    return '<span title="AdCP Spec Compliant">✅</span>';
                } else if (format.validation === false) {
                    return '<span title="AdCP Spec Violations">❌</span>';
                } else {
                    return '<span title="Validation Error">⚠️</span>';
                }
            }

            // AdCP v2.0 spec compliance check for creative formats
            // Based on Format interface at src/lib/types/tools.generated.ts:979
            const adcpViolations = [];

            // REQUIRED fields per AdCP v2.0 spec
            if (!format.format_id) adcpViolations.push('Missing format_id');
            if (!format.name) adcpViolations.push('Missing name');
            if (!format.type) adcpViolations.push('Missing type');

            // Type must be one of the allowed values in AdCP v2.0
            const validTypes = ['audio', 'video', 'display', 'native', 'dooh', 'rich_media', 'universal'];
            if (format.type && !validTypes.includes(format.type)) {
                adcpViolations.push(`Invalid type: ${format.type}`);
            }

            // Validate format_id structure if present
            if (format.format_id && typeof format.format_id === 'object') {
                if (!format.format_id.agent_url) adcpViolations.push('format_id missing agent_url');
                if (!format.format_id.id) adcpViolations.push('format_id missing id');
            }

            // Validate optional arrays if present
            if (format.assets_required && !Array.isArray(format.assets_required)) {
                adcpViolations.push('assets_required must be array');
            }
            if (format.renders && !Array.isArray(format.renders)) {
                adcpViolations.push('renders must be array');
            }
            if (format.output_format_ids && !Array.isArray(format.output_format_ids)) {
                adcpViolations.push('output_format_ids must be array');
            }

            if (adcpViolations.length === 0) {
                return '<span title="AdCP v2.0 Spec Compliant">✅</span>';
            } else if (adcpViolations.length <= 2) {
                return `<span title="Minor violations: ${adcpViolations.join(', ')}" style="color: orange;">⚠️</span>`;
            } else {
                return `<span title="Major violations: ${adcpViolations.join(', ')}" style="color: red;">❌</span>`;
            }
        }

        // ============================================================================
        // Media Buys Table Management
        // ============================================================================
        
        async function refreshMediaBuys() {
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                logEvent('error', 'Please select an agent first');
                return;
            }
            
            logEvent('info', 'Refreshing media buys...');
            
            try {
                // Note: In a real implementation, there would be a get_media_buys tool
                // For now, we'll simulate with get_media_buy_delivery for existing ones
                const result = await callADCPTool(selectedAgent, 'get_media_buy_delivery', {
                    // Use proper AdCP v1.6.0 spec parameters
                    status_filter: 'all', // Get all statuses per official spec
                    start_date: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // Last 30 days
                    end_date: new Date().toISOString().split('T')[0] // Today
                });
                
                if (result && result.media_buys) {
                    mediaBuys = result.media_buys;
                    updateMediaBuysTable();
                    logEvent('success', `Loaded ${mediaBuys.length} media buys`);
                } else {
                    // Start with empty state
                    mediaBuys = [];
                    updateMediaBuysTable();
                    logEvent('info', 'No existing media buys found');
                }
            } catch (error) {
                logEvent('error', `Failed to refresh media buys: ${error.message}`);
                // Show empty state on error
                mediaBuys = [];
                updateMediaBuysTable();
            }
        }
        
        function updateMediaBuysTable() {
            const tbody = document.getElementById('media-buys-tbody');
            
            if (mediaBuys.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" style="padding: 20px; text-align: center; color: #666;">
                            No media buys found. Create a media buy to start tracking campaigns.
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = mediaBuys.map(mediaBuy => {
                const status = getStatusIndicator(mediaBuy.status);
                const spentPercentage = mediaBuy.budget > 0 ? (mediaBuy.spent / mediaBuy.budget * 100).toFixed(1) : '0';
                
                return `
                    <tr data-mb-id="${mediaBuy.id}">
                        <td style="padding: 12px; border: 1px solid #dee2e6;">${mediaBuy.id}</td>
                        <td style="padding: 12px; border: 1px solid #dee2e6;">${status} ${mediaBuy.status}</td>
                        <td style="padding: 12px; border: 1px solid #dee2e6;">$${mediaBuy.budget?.toLocaleString() || '0'}</td>
                        <td style="padding: 12px; border: 1px solid #dee2e6;">$${mediaBuy.spent?.toLocaleString() || '0'} (${spentPercentage}%)</td>
                        <td style="padding: 12px; border: 1px solid #dee2e6;">${(mediaBuy.impressions || 0).toLocaleString()}</td>
                        <td style="padding: 12px; border: 1px solid #dee2e6;">${mediaBuy.ctr || '0'}%</td>
                        <td style="padding: 12px; border: 1px solid #dee2e6;">
                            ${getMediaBuyActions(mediaBuy)}
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        function getStatusIndicator(status) {
            const indicators = {
                'active': '🟢',
                'pending': '🟡',
                'optimizing': '🔵',
                'paused': '⏸️',
                'completed': '✅',
                'error': '🔴',
                'cancelled': '⚫'
            };
            return indicators[status?.toLowerCase()] || '⚪';
        }
        
        function getMediaBuyActions(mediaBuy) {
            const status = mediaBuy.status?.toLowerCase();
            switch (status) {
                case 'pending':
                    return `
                        <button class="btn btn-small" onclick="approveMediaBuy('${mediaBuy.id}')">Approve</button>
                        <button class="btn btn-small" onclick="editMediaBuy('${mediaBuy.id}')">Edit</button>
                        <button class="btn btn-danger btn-small" onclick="cancelMediaBuy('${mediaBuy.id}')">Cancel</button>
                    `;
                case 'active':
                case 'optimizing':
                    return `
                        <button class="btn btn-small" onclick="updateMediaBuy('${mediaBuy.id}')">Update</button>
                        <button class="btn btn-small" onclick="addCreativeAssets('${mediaBuy.id}')">+Creative</button>
                        <button class="btn btn-small" onclick="pauseMediaBuy('${mediaBuy.id}')">⏸</button>
                    `;
                case 'paused':
                    return `
                        <button class="btn btn-small" onclick="resumeMediaBuy('${mediaBuy.id}')">Resume</button>
                        <button class="btn btn-small" onclick="updateMediaBuy('${mediaBuy.id}')">Update</button>
                        <button class="btn btn-danger btn-small" onclick="endMediaBuy('${mediaBuy.id}')">End</button>
                    `;
                default:
                    return `
                        <button class="btn btn-small" onclick="viewMediaBuy('${mediaBuy.id}')">View</button>
                    `;
            }
        }


        // ============================================================================
        // ADCP Tool Execution
        // ============================================================================
        
        /**
         * Call an AdCP tool on a specific agent using typed REST endpoints
         * @param {Object} agent - The agent configuration
         * @param {string} toolName - The AdCP tool name (get_products, sync_creatives, etc.)
         * @param {Object} params - Tool-specific parameters
         * @returns {Promise<Object>} - Tool response with data
         */
        async function callADCPTool(agent, toolName, params) {
            // Map tool names to endpoint paths
            const toolEndpoints = {
                'get_products': 'get-products',
                'list_creative_formats': 'list-creative-formats',
                'create_media_buy': 'create-media-buy',
                'update_media_buy': 'update-media-buy',
                'sync_creatives': 'sync-creatives',
                'list_creatives': 'list-creatives',
                'get_media_buy_delivery': 'get-media-buy-delivery'
            };

            const endpoint = toolEndpoints[toolName];
            if (!endpoint) {
                throw new Error(`Unknown tool: ${toolName}`);
            }

            const url = `/api/agents/${agent.id}/${endpoint}`;

            logEvent('info', `🔄 API Request: POST ${url}`);
            logEvent('info', `📤 Params: ${JSON.stringify(params, null, 2)}`);

            // Include agent config for dynamic agents (custom agents added via UI)
            const requestBody = {
                ...params,
                agentConfig: agent
            };

            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            const result = await response.json();
            logEvent('info', `📥 Response: ${response.status} ${response.statusText}`);

            // Display debug logs if available
            if (result.debug_logs && Array.isArray(result.debug_logs)) {
                displayDebugLogs(result.debug_logs, agent);
            }

            // Handle errors
            if (!response.ok || !result.success) {
                const errorMsg = result.error || `HTTP ${response.status}`;
                logEvent('error', `❌ Error: ${errorMsg}`);
                throw new Error(errorMsg);
            }

            logEvent('success', `✅ ${toolName} completed successfully`);

            // Return the data directly
            return result.data || result;
        }
        
        function collectTestingHeaders() {
            const headers = {};
            
            // Always enable dry run for testing
            headers['X-Dry-Run'] = 'true';
            
            // Add test session if available
            const testSessionId = document.getElementById('test-session-id');
            if (testSessionId && testSessionId.value) {
                headers['X-Test-Session-ID'] = testSessionId.value;
            }
            
            return headers;
        }

        // ============================================================================
        // Create Media Buy Modal Management
        // ============================================================================
        
        function createMediaBuyWithSelected() {
            console.log('createMediaBuyWithSelected called, selectedProducts:', selectedProducts);
            if (selectedProducts.size === 0) {
                logEvent('error', 'Please select at least one product');
                alert('Please select at least one product');
                return;
            }
            
            // Populate selected products summary
            const summary = document.getElementById('selected-products-summary');
            const selectedProductsList = Array.from(selectedProducts).map(productId => {
                const product = products.find(p => p.product_id === productId);
                return product ? `• ${product.name || 'Unnamed Product'} (${product.product_id}) - $${product.cpm || '0'} CPM` : `• ${productId}`;
            }).join('<br>');
            
            summary.innerHTML = selectedProductsList;
            
            // Generate test session ID
            generateNewTestSession();
            
            // Set default dates
            const startDate = document.getElementById('start-date');
            const endDate = document.getElementById('end-date');
            const startAsapCheckbox = document.getElementById('start-asap');
            const today = new Date();
            const nextWeek = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

            startDate.value = today.toISOString().split('T')[0];
            endDate.value = nextWeek.toISOString().split('T')[0];

            // Add event listener to ASAP checkbox
            startAsapCheckbox.addEventListener('change', function() {
                startDate.disabled = this.checked;
                if (this.checked) {
                    startDate.style.opacity = '0.5';
                } else {
                    startDate.style.opacity = '1';
                }
            });

            // Show modal
            document.getElementById('create-media-buy-modal').style.display = 'block';
        }
        
        function closeCreateMediaBuyModal() {
            document.getElementById('create-media-buy-modal').style.display = 'none';
        }
        
        function generateNewTestSession() {
            const sessionId = `test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            document.getElementById('test-session-id').value = sessionId;
        }
        
        function loadTestScenario() {
            const scenario = document.getElementById('test-scenarios').value;
            
            // Set default dates (today to 30 days from now)
            const today = new Date();
            const futureDate = new Date(today.getTime() + (30 * 24 * 60 * 60 * 1000));
            document.getElementById('start-date').value = today.toISOString().split('T')[0];
            document.getElementById('end-date').value = futureDate.toISOString().split('T')[0];
            
            if (!scenario) {
                // Clear all fields if no scenario selected
                document.getElementById('campaign-name').value = '';
                document.getElementById('buyer-ref').value = '';
                document.getElementById('po-number').value = '';
                document.getElementById('promoted-offering').value = '';
                document.getElementById('campaign-budget').value = '';
                document.getElementById('daily-cap').value = '';
                document.getElementById('budget-pacing').value = 'even';
                document.getElementById('geo-countries').value = '';
                document.getElementById('geo-regions').value = '';
                document.getElementById('axe-include').value = '';
                document.getElementById('axe-exclude').value = '';
                document.getElementById('frequency-cap-limit').value = '';
                return;
            }
            
            switch (scenario) {
                case 'basic-campaign':
                    document.getElementById('campaign-name').value = 'Basic Test Campaign';
                    document.getElementById('buyer-ref').value = 'BUYER-2024-BASIC';
                    document.getElementById('po-number').value = 'PO-2024-BASIC-001';
                    document.getElementById('promoted-offering').value = 'Test brand promoting a new product line for awareness and engagement.';
                    document.getElementById('campaign-budget').value = '5000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('budget-pacing').value = 'even';
                    break;
                    
                case 'geo-targeted':
                    document.getElementById('campaign-name').value = 'US/CA Geo-Targeted Campaign';
                    document.getElementById('buyer-ref').value = 'BUYER-2024-GEO';
                    document.getElementById('po-number').value = 'PO-2024-GEO-001';
                    document.getElementById('promoted-offering').value = 'North American brand targeting US and Canada for regional product launch.';
                    document.getElementById('campaign-budget').value = '15000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('daily-cap').value = '1000';
                    document.getElementById('budget-pacing').value = 'even';
                    document.getElementById('geo-countries').value = 'US,CA';
                    document.getElementById('geo-regions').value = 'CA,NY,TX,ON,BC';
                    break;
                    
                case 'axe-segments':
                    document.getElementById('campaign-name').value = 'AXE Segment Targeted Campaign';
                    document.getElementById('buyer-ref').value = 'BUYER-2024-AXE';
                    document.getElementById('po-number').value = 'PO-2024-AXE-001';
                    document.getElementById('promoted-offering').value = 'Premium brand targeting high-value segments while excluding competitor audiences.';
                    document.getElementById('campaign-budget').value = '25000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('daily-cap').value = '2000';
                    document.getElementById('budget-pacing').value = 'front_loaded';
                    document.getElementById('axe-include').value = 'premium-shoppers,tech-enthusiasts';
                    document.getElementById('axe-exclude').value = 'competitor-loyalists,price-sensitive';
                    break;
                    
                case 'frequency-capped':
                    document.getElementById('campaign-name').value = 'Frequency Controlled Campaign';
                    document.getElementById('buyer-ref').value = 'BUYER-2024-FREQ';
                    document.getElementById('po-number').value = 'PO-2024-FREQ-001';
                    document.getElementById('promoted-offering').value = 'Brand focused on optimal frequency to maximize reach without oversaturation.';
                    document.getElementById('campaign-budget').value = '10000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('budget-pacing').value = 'even';
                    document.getElementById('frequency-cap-limit').value = '3';
                    document.getElementById('frequency-cap-period').value = 'day';
                    break;
                    
                case 'premium-budget':
                    document.getElementById('campaign-name').value = 'Premium High-Budget Campaign';
                    document.getElementById('buyer-ref').value = 'BUYER-2024-PREMIUM';
                    document.getElementById('po-number').value = 'PO-2024-PREMIUM-001';
                    document.getElementById('promoted-offering').value = 'Luxury brand with premium budget targeting affluent audiences across multiple markets.';
                    document.getElementById('campaign-budget').value = '100000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('daily-cap').value = '5000';
                    document.getElementById('budget-pacing').value = 'asap';
                    document.getElementById('geo-countries').value = 'US,GB,AU,CA';
                    document.getElementById('axe-include').value = 'luxury-buyers,high-income';
                    document.getElementById('frequency-cap-limit').value = '5';
                    document.getElementById('frequency-cap-period').value = 'week';
                    break;

                // AI-Powered Test Scenarios
                case 'test-delay-response':
                    document.getElementById('campaign-name').value = 'Test: Delayed Response';
                    document.getElementById('buyer-ref').value = 'TEST-DELAY-001';
                    document.getElementById('po-number').value = 'PO-TEST-DELAY-001';
                    document.getElementById('promoted-offering').value = 'Wait 10 seconds before responding';
                    document.getElementById('campaign-budget').value = '5000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('budget-pacing').value = 'even';
                    break;

                case 'test-rejection':
                    document.getElementById('campaign-name').value = 'Test: Rejection Scenario';
                    document.getElementById('buyer-ref').value = 'TEST-REJECT-001';
                    document.getElementById('po-number').value = 'PO-TEST-REJECT-001';
                    document.getElementById('promoted-offering').value = 'Reject this media buy with reason: Budget exceeds available inventory';
                    document.getElementById('campaign-budget').value = '5000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('budget-pacing').value = 'even';
                    break;

                case 'test-human-approval':
                    document.getElementById('campaign-name').value = 'Test: Human Approval Workflow';
                    document.getElementById('buyer-ref').value = 'TEST-HITL-001';
                    document.getElementById('po-number').value = 'PO-TEST-HITL-001';
                    document.getElementById('promoted-offering').value = 'Simulate human approval workflow with 5 minute review delay';
                    document.getElementById('campaign-budget').value = '10000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('budget-pacing').value = 'even';
                    break;

                case 'test-slow-delivery':
                    document.getElementById('campaign-name').value = 'Test: Slow Delivery + Outage';
                    document.getElementById('buyer-ref').value = 'TEST-DELIVERY-001';
                    document.getElementById('po-number').value = 'PO-TEST-DELIVERY-001';
                    document.getElementById('promoted-offering').value = 'Test slow delivery profile, then simulate platform outage on day 3';
                    document.getElementById('campaign-budget').value = '15000';
                    document.getElementById('budget-currency').value = 'USD';
                    document.getElementById('budget-pacing').value = 'even';
                    break;
            }

            logEvent('info', `Loaded test scenario: ${scenario}`);
        }
        
        async function executeCreateMediaBuy() {
            console.log('executeCreateMediaBuy called');
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            console.log('Selected agent:', selectedAgent);
            if (!selectedAgent) {
                logEvent('error', 'Please select an agent first');
                alert('Please select an agent first');
                return;
            }
            
            // Collect form data
            const campaignName = document.getElementById('campaign-name').value || 'Untitled Campaign';
            const buyerRef = document.getElementById('buyer-ref').value;
            const poNumber = document.getElementById('po-number').value;
            const brandManifest = document.getElementById('promoted-offering').value;
            const budget = parseFloat(document.getElementById('campaign-budget').value) || 0;
            const currency = document.getElementById('budget-currency').value || 'USD';
            const dailyCap = document.getElementById('daily-cap').value;
            const pacing = document.getElementById('budget-pacing').value || 'even';
            const startAsap = document.getElementById('start-asap').checked;
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;
            
            // Collect targeting data
            const geoCountries = document.getElementById('geo-countries').value;
            const geoRegions = document.getElementById('geo-regions').value;
            const axeInclude = document.getElementById('axe-include').value;
            const axeExclude = document.getElementById('axe-exclude').value;
            const frequencyCapLimit = document.getElementById('frequency-cap-limit').value;
            const frequencyCapPeriod = document.getElementById('frequency-cap-period').value;
            
            // Validate required fields
            if (!buyerRef) {
                logEvent('error', 'Buyer Reference is required');
                alert('Buyer Reference is required');
                return;
            }
            if (!poNumber) {
                logEvent('error', 'PO Number is required');
                alert('PO Number is required');
                return;
            }
            if (!brandManifest) {
                logEvent('error', 'Advertiser/Offering Description is required');
                alert('Advertiser/Offering Description is required');
                return;
            }
            if (!budget || budget <= 0) {
                logEvent('error', 'Valid budget is required');
                alert('Valid budget is required');
                return;
            }
            
            // Collect testing configuration
            const enableTestMode = document.getElementById('enable-test-mode').checked;
            const jumpToState = document.getElementById('jump-to-state').value;
            
            // Build selected products array
            const selectedProductsData = Array.from(selectedProducts).map(productId => {
                const product = products.find(p => p.product_id === productId);
                return product || { product_id: productId };
            });
            
            try {
                logEvent('info', `Creating media buy: ${campaignName}`);
                
                // Create testing headers
                const testingHeaders = {
                    'X-Dry-Run': enableTestMode ? 'true' : 'false',
                    'X-Test-Session-ID': document.getElementById('test-session-id').value
                };
                
                if (jumpToState) {
                    testingHeaders['X-Jump-To-Event'] = jumpToState;
                }
                
                // Build ADCP-compliant budget structure
                const budgetConfig = {
                    total: budget,
                    currency: currency
                };
                if (dailyCap) budgetConfig.daily_cap = parseFloat(dailyCap);
                if (pacing) budgetConfig.pacing = pacing;
                
                // Build targeting overlay
                const targetingOverlay = {};
                if (geoCountries) targetingOverlay.geo_country_any_of = geoCountries.split(',').map(c => c.trim());
                if (geoRegions) targetingOverlay.geo_region_any_of = geoRegions.split(',').map(r => r.trim());
                if (axeInclude) targetingOverlay.axe_include_segment = axeInclude.split(',').map(s => s.trim());
                if (axeExclude) targetingOverlay.axe_exclude_segment = axeExclude.split(',').map(s => s.trim());
                if (frequencyCapLimit) {
                    targetingOverlay.frequency_cap = {
                        limit: parseInt(frequencyCapLimit),
                        period: frequencyCapPeriod || 'day'
                    };
                }
                
                // Build packages array from selected products
                const packages = selectedProductsData.map(product => ({
                    product_id: product.product_id,
                    targeting_overlay: Object.keys(targetingOverlay).length > 0 ? targetingOverlay : undefined
                }));

                // brand_manifest must be either a valid URL or a BrandManifest object
                let brandManifestParam = brandManifest;
                try {
                    new URL(brandManifest);
                    // It's a valid URL, use as-is
                } catch {
                    // Not a URL, wrap in BrandManifest object per AdCP spec
                    brandManifestParam = {
                        name: brandManifest
                    };
                }

                // Build ADCP create_media_buy parameters
                const createMediaBuyParams = {
                    buyer_ref: buyerRef,
                    packages: packages,
                    brand_manifest: brandManifestParam,
                    po_number: poNumber,
                    start_time: startAsap ? 'asap' : (startDate ? new Date(startDate).toISOString() : new Date().toISOString()),
                    end_time: endDate ? new Date(endDate).toISOString() : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                    budget: budgetConfig
                };
                
                console.log('🚀 ADCP create_media_buy request:', createMediaBuyParams);
                
                // Add ADCP request to debug panel
                const requestEntry = document.createElement('div');
                requestEntry.className = 'debug-entry';
                requestEntry.innerHTML = `
                    <div class="debug-header">
                        <span style="color: #333; font-weight: bold;">📤 ADCP create_media_buy Request</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="debug-content-item">
                        <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 12px; overflow-x: auto; color: #333;">${JSON.stringify(createMediaBuyParams, null, 2)}</pre>
                    </div>
                `;
                
                debugEntries.push({
                    type: 'adcp-request',
                    element: requestEntry,
                    timestamp: Date.now(),
                    isError: false
                });
                
                // Execute create_media_buy tool with ADCP-compliant parameters
                const result = await callADCPTool(selectedAgent, 'create_media_buy', createMediaBuyParams);
                
                console.log('✅ ADCP create_media_buy response:', result);

                // Check if response contains errors
                const responseHasErrors = result.errors && Array.isArray(result.errors) && result.errors.length > 0;

                // Add ADCP response to debug panel
                const responseEntry = document.createElement('div');
                responseEntry.className = responseHasErrors ? 'debug-entry error' : 'debug-entry';
                const responseIcon = responseHasErrors ? '❌' : '📥';
                const responseStyle = responseHasErrors ? 'background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); padding: 10px; border-radius: 4px; font-size: 12px; overflow-x: auto; color: #dc2626;' : 'background: #f8f9fa; padding: 10px; border-radius: 4px; font-size: 12px; overflow-x: auto; color: #333;';

                responseEntry.innerHTML = `
                    <div class="debug-header">
                        <span style="color: ${responseHasErrors ? '#dc2626' : '#333'}; font-weight: bold;">${responseIcon} ADCP create_media_buy Response ${responseHasErrors ? '(ERROR)' : ''}</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="debug-content-item">
                        <pre style="${responseStyle}">${JSON.stringify(result, null, 2)}</pre>
                    </div>
                `;

                debugEntries.push({
                    type: 'adcp-response',
                    element: responseEntry,
                    timestamp: Date.now(),
                    isError: responseHasErrors
                });
                
                // Redraw debug panel to show new entries
                redrawDebugEntries();

                // Check if the response has errors
                const hasErrors = result.errors && Array.isArray(result.errors) && result.errors.length > 0;
                const hasMediaBuyId = result.media_buy_id && result.media_buy_id !== null;

                if (hasErrors) {
                    // Show error details
                    const errorMessages = result.errors.map(err =>
                        `[${err.code}] ${err.message}${err.details ? '\nDetails: ' + JSON.stringify(err.details) : ''}`
                    ).join('\n\n');

                    logEvent('error', `Media buy creation failed:\n${errorMessages}`);
                    alert(`Media buy creation failed:\n\n${errorMessages}`);

                    // Don't add to media buys list or close modal on error
                    return;
                }

                if (!hasMediaBuyId) {
                    logEvent('error', 'Media buy creation failed: No media_buy_id returned');
                    alert('Media buy creation failed: No media_buy_id returned');
                    return;
                }

                logEvent('success', `Media buy created: ${result.media_buy_id}`);

                // Add to media buys list only on success
                const newMediaBuy = {
                    id: result.media_buy_id,
                    name: campaignName,
                    status: result.status || 'pending',
                    budget: budget,
                    spent: 0,
                    impressions: 0,
                    ctr: 0,
                    created: new Date().toISOString()
                };

                mediaBuys.push(newMediaBuy);
                updateMediaBuysTable();

                // Clear selection and close modal
                selectedProducts.clear();
                updateProductsTable();
                closeCreateMediaBuyModal();
                
            } catch (error) {
                logEvent('error', `Failed to create media buy: ${error.message}`);
            }
        }

        // ============================================================================
        // Media Buy Action Handlers
        // ============================================================================
        
        async function addCreativeAssets(mediaBuyId) {
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                logEvent('error', 'Please select an agent first');
                return;
            }
            
            // Ensure we have creative formats loaded
            if (creativeFormats.length === 0) {
                logEvent('warning', 'No creative formats available. Loading formats first...');
                await refreshCreativeFormats();
            }
            
            // Open the creative asset modal
            openCreativeAssetModal(mediaBuyId);
        }
        
        function openCreativeAssetModal(mediaBuyId) {
            const modal = createCreativeAssetModal(mediaBuyId);
            document.body.appendChild(modal);
            modal.style.display = 'flex';
            
            // Populate format selector with available formats
            populateFormatSelector();
            
            // Populate package assignments from current products
            populatePackageAssignments();
            
            logEvent('info', `Opened creative asset modal for media buy ${mediaBuyId}`);
        }
        
        function createCreativeAssetModal(mediaBuyId) {
            const modal = document.createElement('div');
            modal.id = 'creative-asset-modal';
            modal.className = 'modal-backdrop';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                    <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; padding: 20px; border-bottom: 1px solid #dee2e6;">
                        <h3>🎨 Upload Creative Assets</h3>
                        <span style="font-size: 14px; color: #666;">Media Buy: ${mediaBuyId}</span>
                    </div>
                    
                    <div class="modal-body" style="padding: 20px;">
                        <div class="section" style="margin-bottom: 25px;">
                            <h4>📋 Select Creative Formats</h4>
                            <div id="format-selector" style="max-height: 200px; overflow-y: auto; border: 1px solid #dee2e6; padding: 15px; border-radius: 4px; background: #f8f9fa;">
                                <div style="text-align: center; color: #666; padding: 20px;">Loading formats...</div>
                            </div>
                            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                💡 Select one or more formats to generate sample creatives for
                            </div>
                        </div>
                        
                        <div class="section" style="margin-bottom: 25px;">
                            <h4>⚙️ Asset Configuration</h4>
                            <div class="form-group">
                                <label for="creative-name-prefix" style="display: block; margin-bottom: 5px; font-weight: bold;">Creative Name Prefix:</label>
                                <input type="text" id="creative-name-prefix" 
                                       value="Creative_${Date.now()}" 
                                       style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px;">
                            </div>
                            
                            <div class="form-group" style="margin-top: 15px;">
                                <label style="display: flex; align-items: center; font-weight: bold;">
                                    <input type="checkbox" id="generate-samples" checked style="margin-right: 8px;">
                                    Generate sample creatives automatically
                                </label>
                                <div style="margin-left: 20px; font-size: 12px; color: #666;">
                                    Creates placeholder assets matching each format's specifications
                                </div>
                            </div>
                        </div>
                        
                        <div class="section" style="margin-bottom: 25px;">
                            <h4>📦 Package Assignments</h4>
                            <div id="package-assignments" style="border: 1px solid #dee2e6; padding: 15px; border-radius: 4px; background: #f8f9fa;">
                                <div style="text-align: center; color: #666; padding: 20px;">Loading packages...</div>
                            </div>
                            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                Select which packages these creatives will be assigned to
                            </div>
                        </div>
                        
                        <div class="section">
                            <h4>📊 Preview</h4>
                            <div id="creative-preview" style="border: 1px solid #dee2e6; padding: 15px; border-radius: 4px; background: #f8f9fa; min-height: 60px;">
                                <div style="text-align: center; color: #666;">Select formats and configuration to preview assets</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 10px; padding: 20px; border-top: 1px solid #dee2e6;">
                        <button class="btn btn-secondary" onclick="closeCreativeAssetModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="generateAndUploadCreatives('${mediaBuyId}')" id="generate-upload-btn">
                            🚀 Generate & Upload Assets
                        </button>
                    </div>
                </div>
            `;
            
            // Add modal styles if not already present
            if (!document.getElementById('creative-asset-modal-styles')) {
                const styles = document.createElement('style');
                styles.id = 'creative-asset-modal-styles';
                styles.textContent = `
                    .modal-backdrop {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 1000;
                    }
                    
                    .format-option {
                        display: flex;
                        align-items: center;
                        padding: 8px;
                        margin-bottom: 5px;
                        border: 1px solid #dee2e6;
                        border-radius: 4px;
                        background: white;
                        cursor: pointer;
                        transition: background-color 0.2s;
                    }
                    
                    .format-option:hover {
                        background: #e9ecef;
                    }
                    
                    .format-option input[type="checkbox"] {
                        margin-right: 10px;
                    }
                    
                    .format-badge {
                        font-size: 11px;
                        padding: 2px 6px;
                        border-radius: 3px;
                        margin-left: 8px;
                        font-weight: bold;
                    }
                    
                    .format-badge.agent {
                        background: #d4edda;
                        color: #155724;
                    }
                    
                    .format-badge.standard {
                        background: #cce5ff;
                        color: #004085;
                    }
                `;
                document.head.appendChild(styles);
            }
            
            return modal;
        }
        
        function populateFormatSelector() {
            const selector = document.getElementById('format-selector');
            if (!selector) return;
            
            if (creativeFormats.length === 0) {
                selector.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No formats available</div>';
                return;
            }
            
            selector.innerHTML = creativeFormats.map(format => `
                <div class="format-option" onclick="toggleFormatSelection('${format.format_id}')">
                    <input type="checkbox" id="format_${format.format_id}" value="${format.format_id}" 
                           onchange="updatePreview()">
                    <div style="flex: 1;">
                        <div style="font-weight: bold;">${format.name || format.format_id}</div>
                        <div style="font-size: 12px; color: #666;">
                            ${format.type || 'Unknown type'} • ${format.is_standard ? 'IAB Standard' : 'Custom format'}
                        </div>
                        ${format.requirements ? `<div style="font-size: 11px; color: #999; margin-top: 2px;">${format.requirements}</div>` : ''}
                    </div>
                    <span class="format-badge ${format.source === 'agent' ? 'agent' : 'standard'}">
                        ${format.source === 'agent' ? '🤖' : '📚'} ${format.source || 'unknown'}
                    </span>
                </div>
            `).join('');
        }
        
        function populatePackageAssignments() {
            const assignments = document.getElementById('package-assignments');
            if (!assignments) return;
            
            if (!products || products.length === 0) {
                assignments.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No packages available</div>';
                return;
            }
            
            assignments.innerHTML = products.map(product => `
                <label style="display: flex; align-items: center; margin-bottom: 8px; cursor: pointer;">
                    <input type="checkbox" value="${product.package_id}" checked 
                           onchange="updatePreview()" style="margin-right: 8px;">
                    <div>
                        <div style="font-weight: bold;">${product.name}</div>
                        <div style="font-size: 12px; color: #666;">ID: ${product.package_id}</div>
                    </div>
                </label>
            `).join('');
        }
        
        function toggleFormatSelection(formatId) {
            const checkbox = document.getElementById(`format_${formatId}`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                updatePreview();
            }
        }
        
        function updatePreview() {
            const preview = document.getElementById('creative-preview');
            if (!preview) return;
            
            const selectedFormats = getSelectedFormats();
            const selectedPackages = getSelectedPackages();
            const namePrefix = document.getElementById('creative-name-prefix')?.value || 'Creative';
            const generateSamples = document.getElementById('generate-samples')?.checked;
            
            if (selectedFormats.length === 0) {
                preview.innerHTML = '<div style="text-align: center; color: #666;">Select formats to preview assets</div>';
                return;
            }
            
            const previewContent = `
                <div style="margin-bottom: 15px;">
                    <strong>📊 Asset Preview</strong>
                </div>
                <div style="display: grid; gap: 10px;">
                    <div><strong>Formats Selected:</strong> ${selectedFormats.length} (${selectedFormats.map(f => f.name).join(', ')})</div>
                    <div><strong>Assets to Generate:</strong> ${selectedFormats.length} creative${selectedFormats.length > 1 ? 's' : ''}</div>
                    <div><strong>Package Assignments:</strong> ${selectedPackages.length} package${selectedPackages.length > 1 ? 's' : ''}</div>
                    <div><strong>Sample Generation:</strong> ${generateSamples ? '✅ Enabled' : '❌ Disabled'}</div>
                    <div><strong>Naming:</strong> ${namePrefix}_[format_id]_${Date.now()}</div>
                </div>
                
                ${selectedFormats.length > 0 ? `
                    <div style="margin-top: 15px;">
                        <strong>Assets to Create:</strong>
                        <div style="margin-top: 8px;">
                            ${selectedFormats.map(format => `
                                <div style="padding: 6px 10px; background: #e9ecef; border-radius: 3px; margin-bottom: 4px; font-size: 12px;">
                                    📁 ${namePrefix}_${format.format_id}_${Date.now()}
                                    <span style="color: #666; margin-left: 10px;">(${format.type || 'unknown'} format)</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            `;
            
            preview.innerHTML = previewContent;
        }
        
        function getSelectedFormats() {
            return creativeFormats.filter(format => {
                const checkbox = document.getElementById(`format_${format.format_id}`);
                return checkbox && checkbox.checked;
            });
        }
        
        function getSelectedPackages() {
            const checkboxes = document.querySelectorAll('#package-assignments input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }
        
        function closeCreativeAssetModal() {
            const modal = document.getElementById('creative-asset-modal');
            if (modal) {
                modal.remove();
                logEvent('info', 'Closed creative asset modal');
            }
        }
        
        async function generateAndUploadCreatives(mediaBuyId) {
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                logEvent('error', 'No agent selected');
                return;
            }
            
            const selectedFormats = getSelectedFormats();
            const selectedPackages = getSelectedPackages();
            const namePrefix = document.getElementById('creative-name-prefix')?.value || 'Creative';
            const generateSamples = document.getElementById('generate-samples')?.checked;
            
            if (selectedFormats.length === 0) {
                logEvent('error', 'Please select at least one format');
                return;
            }
            
            if (selectedPackages.length === 0) {
                logEvent('error', 'Please select at least one package assignment');
                return;
            }
            
            // Show loading state
            const btn = document.getElementById('generate-upload-btn');
            const originalText = btn.textContent;
            btn.textContent = '⏳ Generating...';
            btn.disabled = true;
            
            try {
                // Generate creative assets based on selected formats
                const assets = [];
                for (const format of selectedFormats) {
                    const asset = generateSampleCreative(format, namePrefix, generateSamples);
                    asset.package_assignments = selectedPackages;
                    assets.push(asset);
                }
                
                logEvent('info', `Generated ${assets.length} creative assets`);
                
                // Call ADCP manage_creative_assets with upload action
                // Build sync_creatives params
                const syncParams = {
                    creatives: assets
                };

                // Add assignments if media buy is specified
                if (mediaBuyId) {
                    syncParams.assignments = {};
                    assets.forEach(asset => {
                        const creativeId = asset.id || asset.creative_id || asset.creativeId;
                        if (creativeId) {
                            syncParams.assignments[creativeId] = [mediaBuyId];
                        }
                    });
                }

                const result = await callADCPTool(selectedAgent, 'sync_creatives', syncParams);
                
                logEvent('success', `Successfully uploaded ${assets.length} creative assets to ${mediaBuyId}`);
                
                // Display results if available
                if (result.results?.uploaded) {
                    displayAssetUploadResults(result.results.uploaded);
                } else if (result.asset_statuses) {
                    // Fallback for legacy response format
                    displayAssetUploadResults(result.asset_statuses);
                }
                
                // Close modal and refresh media buys
                closeCreativeAssetModal();
                refreshMediaBuys();
                
            } catch (error) {
                logEvent('error', `Failed to upload creative assets: ${error.message}`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }
        
        function generateSampleCreative(format, namePrefix, generateSample) {
            const creative = {
                creative_id: `${namePrefix}_${format.format_id}_${Date.now()}`,
                name: `${namePrefix} - ${format.name || format.format_id}`,
                format: format.format_id,
                media_url: null,
                package_assignments: [] // Will be filled by caller
            };
            
            if (generateSample) {
                // Generate appropriate sample based on format type
                if (format.type === 'display' || format.type === 'banner') {
                    creative.media_url = generatePlaceholderImageUrl(format);
                } else if (format.type === 'video') {
                    creative.media_url = generatePlaceholderVideoUrl(format);
                } else if (format.type === 'native') {
                    creative.media_url = generateNativeTemplateUrl(format);
                } else {
                    creative.media_url = generateGenericPlaceholderUrl(format);
                }
            }
            
            return creative;
        }
        
        function generatePlaceholderImageUrl(format) {
            // Extract dimensions from format if available
            let width = 300, height = 250;
            
            if (format.assets_required && Array.isArray(format.assets_required)) {
                const imageAsset = format.assets_required.find(asset => 
                    asset.asset_type === 'image' || asset.width || asset.height
                );
                if (imageAsset) {
                    width = imageAsset.width || width;
                    height = imageAsset.height || height;
                }
            }
            
            // Use a placeholder image service
            return `https://via.placeholder.com/${width}x${height}/007bff/ffffff?text=${encodeURIComponent(format.name || format.format_id)}`;
        }
        
        function generatePlaceholderVideoUrl(format) {
            // For video, return a placeholder that indicates video content
            return `https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4`;
        }
        
        function generateNativeTemplateUrl(format) {
            // For native, return a JSON template URL or placeholder
            return `data:application/json,${encodeURIComponent(JSON.stringify({
                template: 'native_ad',
                format_id: format.format_id,
                assets: format.assets_required || []
            }))}`;
        }
        
        function generateGenericPlaceholderUrl(format) {
            return `data:text/plain,${encodeURIComponent(`Sample creative for ${format.name || format.format_id} format`)}`;
        }
        
        function displayAssetUploadResults(assetStatuses) {
            if (!assetStatuses || assetStatuses.length === 0) return;
            
            const results = assetStatuses.map(status => {
                const statusIcon = status.status === 'approved' ? '✅' : 
                                 status.status === 'pending_review' ? '⏳' : '❌';
                return `${statusIcon} ${status.creative_id}: ${status.status}`;
            }).join('<br>');
            
            logEvent('info', `Asset Upload Results:<br>${results}`);
        }
        
        async function updateMediaBuy(mediaBuyId) {
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                logEvent('error', 'Please select an agent first');
                return;
            }
            
            const updates = { status: 'optimizing' };
            
            try {
                const result = await callADCPTool(selectedAgent, 'update_media_buy', {
                    media_buy_id: mediaBuyId,
                    updates: updates
                });
                
                logEvent('success', `Media buy ${mediaBuyId} updated`);
            } catch (error) {
                logEvent('error', `Failed to update media buy: ${error.message}`);
            }
        }
        
        function pauseMediaBuy(mediaBuyId) {
            logEvent('info', `Pausing media buy ${mediaBuyId}`);
            // Simulate status change
            updateMediaBuyStatus({ media_buy_id: mediaBuyId, status: 'paused' });
        }
        
        function resumeMediaBuy(mediaBuyId) {
            logEvent('info', `Resuming media buy ${mediaBuyId}`);
            // Simulate status change
            updateMediaBuyStatus({ media_buy_id: mediaBuyId, status: 'active' });
        }
        
        function approveMediaBuy(mediaBuyId) {
            logEvent('info', `Approving media buy ${mediaBuyId}`);
            // Simulate status change
            updateMediaBuyStatus({ media_buy_id: mediaBuyId, status: 'active' });
        }
        
        function cancelMediaBuy(mediaBuyId) {
            if (confirm('Are you sure you want to cancel this media buy?')) {
                logEvent('info', `Cancelling media buy ${mediaBuyId}`);
                updateMediaBuyStatus({ media_buy_id: mediaBuyId, status: 'cancelled' });
            }
        }
        
        function viewMediaBuy(mediaBuyId) {
            const mediaBuy = mediaBuys.find(mb => mb.id === mediaBuyId);
            if (!mediaBuy) {
                alert('Media buy not found');
                return;
            }

            // Create a modal or expandable view showing media buy details
            const detailsHTML = `
                <div style="background: white; padding: 20px; border-radius: 8px; max-width: 600px; margin: 20px auto;">
                    <h3>Media Buy Details</h3>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">Media Buy ID:</td>
                            <td style="padding: 8px;">${mediaBuy.id}</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">Name:</td>
                            <td style="padding: 8px;">${mediaBuy.name || 'Unnamed Campaign'}</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">Status:</td>
                            <td style="padding: 8px;">${mediaBuy.status}</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">Budget:</td>
                            <td style="padding: 8px;">$${mediaBuy.budget?.toLocaleString() || '0'}</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">Spent:</td>
                            <td style="padding: 8px;">$${mediaBuy.spent?.toLocaleString() || '0'} (${mediaBuy.budget ? ((mediaBuy.spent / mediaBuy.budget) * 100).toFixed(1) : '0'}%)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">Impressions:</td>
                            <td style="padding: 8px;">${mediaBuy.impressions?.toLocaleString() || '0'}</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">CTR:</td>
                            <td style="padding: 8px;">${mediaBuy.ctr || '0'}%</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 8px; font-weight: bold;">Created:</td>
                            <td style="padding: 8px;">${mediaBuy.created ? new Date(mediaBuy.created).toLocaleString() : 'Unknown'}</td>
                        </tr>
                    </table>
                    <div style="margin-top: 20px;">
                        <pre style="background: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto;">${JSON.stringify(mediaBuy, null, 2)}</pre>
                    </div>
                </div>
            `;

            // Show in an alert as a simple solution (could be enhanced with a modal)
            logEvent('info', `Viewing media buy: ${mediaBuy.id}`);

            // Create a temporary container to display the details
            const existingView = document.getElementById('media-buy-detail-view');
            if (existingView) {
                existingView.remove();
            }

            const detailView = document.createElement('div');
            detailView.id = 'media-buy-detail-view';
            detailView.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow: auto;';
            detailView.innerHTML = detailsHTML + '<button onclick="document.getElementById(\'media-buy-detail-view\').remove()" style="margin-top: 10px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>';
            document.body.appendChild(detailView);
        }
        

        // ============================================================================
        // Enhanced Debug Panel Functions
        // ============================================================================
        
        let debugPanelOpen = false; // Start with panel hidden by default
        let currentDebugTab = 'debug';
        let debugEntries = [];
        let eventStoreData = []; // Store events from event store
        let currentOperationPrefix = null; // Track current operation prefix for filtering
        
        function toggleDebugPanel() {
            debugPanelOpen = !debugPanelOpen;
            const panel = document.getElementById('debug-panel');
            const mainContent = document.getElementById('main-content');
            const btnText = document.getElementById('debug-btn-text');
            const btnIcon = document.getElementById('debug-btn-icon');
            const toggleBtn = document.querySelector('.toggle-debug-btn');
            
            if (debugPanelOpen) {
                panel.classList.add('open');
                mainContent.classList.add('debug-open');
                toggleBtn.classList.add('panel-open');
                btnText.textContent = 'Hide Debug';
                btnIcon.textContent = '✖️';
            } else {
                panel.classList.remove('open');
                mainContent.classList.remove('debug-open');
                toggleBtn.classList.remove('panel-open');
                btnText.textContent = 'Show Debug';
                btnIcon.textContent = '🔍';
            }
        }
        
        async function showDebugTab(tab) {
            currentDebugTab = tab;

            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if (btn.dataset.tab === tab) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Stop polling if switching away from event tabs
            if (eventPollInterval && tab === 'debug') {
                clearInterval(eventPollInterval);
                eventPollInterval = null;
            }

            // If switching to event store tabs, fetch fresh data and start polling
            if (tab === 'events' || tab === 'tasks' || tab === 'notifications') {
                await refreshEventStore();

                // Start auto-refresh every 3 seconds
                if (!eventPollInterval) {
                    eventPollInterval = setInterval(async () => {
                        if (currentDebugTab !== 'debug' && debugPanelOpen) {
                            await refreshEventStore();
                            redrawDebugEntries();
                        }
                    }, 3000);
                }
            }

            // Filter and redraw entries
            redrawDebugEntries();
        }
        
        function redrawDebugEntries() {
            const content = document.getElementById('debug-content');
            content.innerHTML = '';

            // Handle event store tabs
            if (currentDebugTab === 'events') {
                displayEventsTab();
                return;
            } else if (currentDebugTab === 'tasks') {
                displayTasksTab();
                return;
            } else if (currentDebugTab === 'notifications') {
                displayNotificationsTab();
                return;
            }

            // Handle debug logs tab (original functionality)
            const filteredEntries = debugEntries.filter(entry => {
                // Show all entries for 'debug' tab
                return true;
            });

            filteredEntries.forEach(entry => {
                content.appendChild(entry.element);
            });

            if (filteredEntries.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No debug logs to display</div>';
            }
        }
        
        function clearDebugLog() {
            debugEntries = [];
            redrawDebugEntries();
        }
        
        function clearAllDebugLogs() {
            debugEntries = [];
            redrawDebugEntries();
            // Also clear any stored debug data
            if (window.sessionStorage) {
                window.sessionStorage.removeItem('debugEntries');
            }
            console.log('All debug logs cleared');
        }
        
        function copyAllDebugLogs() {
            if (!debugEntries || debugEntries.length === 0) {
                alert('No debug logs to copy');
                return;
            }
            
            let copyText = '=== AdCP Debug Logs ===\n';
            copyText += `Generated: ${new Date().toISOString()}\n`;
            copyText += `Total Entries: ${debugEntries.length}\n\n`;
            
            debugEntries.forEach((entry, index) => {
                copyText += `--- Entry ${index + 1}: ${entry.title} ---\n`;
                copyText += `Time: ${entry.timestamp}\n`;
                copyText += `Type: ${entry.type}\n`;
                if (entry.method) copyText += `Method: ${entry.method}\n`;
                if (entry.protocol) copyText += `Protocol: ${entry.protocol}\n`;
                if (entry.url) copyText += `URL: ${entry.url}\n`;
                if (entry.headers) copyText += `Headers: ${JSON.stringify(entry.headers, null, 2)}\n`;
                if (entry.body) {
                    copyText += `Body:\n${typeof entry.body === 'string' ? entry.body : JSON.stringify(entry.body, null, 2)}\n`;
                }
                copyText += '\n';
            });
            
            copyText += '=== End Debug Logs ===';
            
            // Copy to clipboard
            navigator.clipboard.writeText(copyText).then(() => {
                // Show temporary success message
                const button = document.querySelector('button[onclick="copyAllDebugLogs()"]');
                const originalText = button.innerHTML;
                button.innerHTML = '✅ Copied!';
                button.style.background = '#198754';
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.background = '#28a745';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy to clipboard:', err);
                // Fallback: show text in a modal or alert
                alert('Copy failed. Debug logs:\n\n' + copyText);
            });
        }

        // ============================================================================
        // Event Store Functions
        // ============================================================================

        async function refreshEventStore() {
            try {
                // Fetch recent events (no filter = last 100 events by default)
                const response = await fetch('/api/events?limit=200');
                const result = await response.json();

                if (result.success) {
                    eventStoreData = result.events || [];
                    console.log(`[EVENT STORE] Loaded ${eventStoreData.length} events`);
                } else {
                    console.error('[EVENT STORE] Failed to fetch events:', result.error);
                    eventStoreData = [];
                }
            } catch (error) {
                console.error('[EVENT STORE] Error fetching events:', error);
                eventStoreData = [];
            }
        }

        function displayEventsTab() {
            const content = document.getElementById('debug-content');

            // Filter for protocol events
            const protocolEvents = eventStoreData.filter(e =>
                e.type === 'protocol_request' ||
                e.type === 'protocol_response' ||
                e.type === 'activity'
            );

            if (protocolEvents.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No protocol events found</div>';
                return;
            }

            protocolEvents.forEach(event => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'debug-entry ' + (event.type === 'protocol_request' ? 'request' : 'response');

                const timestamp = new Date(event.timestamp).toLocaleTimeString();
                const eventType = event.type.replace('protocol_', '').toUpperCase();

                eventDiv.innerHTML = `
                    <div class="debug-entry-header">
                        <div class="debug-entry-title">${eventType}: ${event.operation_id || 'N/A'}</div>
                        <div class="debug-entry-time">${timestamp}</div>
                    </div>
                    <div class="debug-entry-details">
                        <div><strong>Agent:</strong> ${event.agent_id || 'N/A'}</div>
                        <div><strong>Task:</strong> ${event.task_type || 'N/A'}</div>
                        ${event.status ? `<div><strong>Status:</strong> ${event.status}</div>` : ''}
                        ${event.payload ? `<details style="margin-top: 8px;">
                            <summary style="cursor: pointer; color: #4a9eff;">View Payload</summary>
                            <pre class="debug-json">${escapeHtml(JSON.stringify(event.payload, null, 2))}</pre>
                        </details>` : ''}
                    </div>
                `;

                content.appendChild(eventDiv);
            });
        }

        function displayTasksTab() {
            const content = document.getElementById('debug-content');

            // Filter for task status events
            const taskEvents = eventStoreData.filter(e =>
                e.type === 'handler_called' ||
                e.type === 'status_update' ||
                e.status
            );

            if (taskEvents.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No task events found</div>';
                return;
            }

            // Group by operation_id
            const grouped = {};
            taskEvents.forEach(event => {
                const opId = event.operation_id || 'unknown';
                if (!grouped[opId]) grouped[opId] = [];
                grouped[opId].push(event);
            });

            Object.entries(grouped).forEach(([opId, events]) => {
                const taskDiv = document.createElement('div');
                taskDiv.className = 'debug-entry';

                const latestEvent = events[0];
                const timestamp = new Date(latestEvent.timestamp).toLocaleTimeString();
                const statusClass = latestEvent.status === 'completed' ? 'success' :
                                  latestEvent.status === 'failed' ? 'error' : 'pending';

                taskDiv.innerHTML = `
                    <div class="debug-entry-header">
                        <div class="debug-entry-title">
                            ${latestEvent.task_type || 'Task'}
                            <span class="debug-status ${statusClass}">${latestEvent.status || 'unknown'}</span>
                        </div>
                        <div class="debug-entry-time">${timestamp}</div>
                    </div>
                    <div class="debug-entry-details">
                        <div><strong>Operation:</strong> ${opId}</div>
                        <div><strong>Agent:</strong> ${latestEvent.agent_id || 'N/A'}</div>
                        <div><strong>Events:</strong> ${events.length}</div>
                        <details style="margin-top: 8px;">
                            <summary style="cursor: pointer; color: #4a9eff;">View History (${events.length} events)</summary>
                            <div style="margin-top: 8px;">
                                ${events.map((e, i) => `
                                    <div style="padding: 4px 0; border-top: 1px solid #333;">
                                        <strong>${i + 1}.</strong> ${e.type} - ${e.status || 'N/A'}
                                        <span style="color: #999; font-size: 11px;">(${new Date(e.timestamp).toLocaleTimeString()})</span>
                                    </div>
                                `).join('')}
                            </div>
                        </details>
                    </div>
                `;

                content.appendChild(taskDiv);
            });
        }

        function displayNotificationsTab() {
            const content = document.getElementById('debug-content');

            // Filter for notification events
            const notificationEvents = eventStoreData.filter(e =>
                e.type === 'notification_received' ||
                e.type === 'webhook_received'
            );

            if (notificationEvents.length === 0) {
                content.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No notifications found</div>';
                return;
            }

            notificationEvents.forEach(event => {
                const notifDiv = document.createElement('div');
                notifDiv.className = 'debug-entry';

                const timestamp = new Date(event.timestamp).toLocaleTimeString();

                notifDiv.innerHTML = `
                    <div class="debug-entry-header">
                        <div class="debug-entry-title">📬 ${event.type.replace(/_/g, ' ').toUpperCase()}</div>
                        <div class="debug-entry-time">${timestamp}</div>
                    </div>
                    <div class="debug-entry-details">
                        <div><strong>Operation:</strong> ${event.operation_id || 'N/A'}</div>
                        <div><strong>Agent:</strong> ${event.agent_id || 'N/A'}</div>
                        ${event.task_type ? `<div><strong>Task:</strong> ${event.task_type}</div>` : ''}
                        ${event.status ? `<div><strong>Status:</strong> ${event.status}</div>` : ''}
                        ${event.payload ? `<details style="margin-top: 8px;">
                            <summary style="cursor: pointer; color: #4a9eff;">View Notification Data</summary>
                            <pre class="debug-json">${escapeHtml(JSON.stringify(event.payload, null, 2))}</pre>
                        </details>` : ''}
                    </div>
                `;

                content.appendChild(notifDiv);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function displayDebugLogs(logs, agent) {
            if (!logs || !Array.isArray(logs)) {
                return;
            }
            
            // Clear the initial "waiting" message when we get first logs
            if (debugEntries.length === 0 && logs.length > 0) {
                const content = document.getElementById('debug-content');
                if (content && content.innerHTML.includes('Waiting for agent communication')) {
                    content.innerHTML = '';
                }
            }
            
            // Separate operation logs from other logs
            const operationLogs = logs.filter(l => l.type === 'operation');
            const nonOperationLogs = logs.filter(l => l.type !== 'operation');
            
            
            // Handle hierarchical operation logs
            operationLogs.forEach((log, logIndex) => {
                displayOperationLog(log, agent, logIndex);
            });
            
            // Handle non-operation logs (authentic or legacy)
            if (nonOperationLogs.length > 0) {
                const hasAuthenticLogs = nonOperationLogs.some(l => 
                    l.type === 'info' || l.type === 'success' || l.type === 'error'
                );
                
                if (hasAuthenticLogs) {
                    // Use new authentic log display
                    displayAuthenticLogs(nonOperationLogs, agent);
                } else {
                    // Use legacy display for old synthetic logs
                    const pairs = groupLogsIntoPairs(nonOperationLogs);
                    displayLegacyPairs(pairs, agent);
                }
            } else {
            }
            
            // Auto-scroll to bottom
            const content = document.getElementById('debug-content');
            content.scrollTop = content.scrollHeight;
        }
        
        function displayOperationLog(operationLog, agent, operationIndex) {
            try {
                const callId = `operation-${Date.now()}-${operationIndex}`;
                const operationName = operationLog.operation.replace(/_/g, ' ').toUpperCase();
                
                let statusClass = operationLog.status === 'success' ? 'success' : 'error';
                let statusIcon = operationLog.status === 'success' ? '✅' : '❌';
                let isError = operationLog.status !== 'success';
                
                // Create collapsible operation container
                const operationEntry = document.createElement('div');
                operationEntry.className = `debug-pair operation ${isError ? 'error' : ''}`;
                
                const timestamp = new Date(operationLog.timestamp).toLocaleTimeString();
                
                // Create steps HTML
                const stepsHTML = operationLog.steps.map((step, i) => {
                    const stepStatus = step.status >= 400 ? 'error' : 'success';
                    const stepIcon = step.status >= 400 ? '❌' : '✅';
                    return `
                        <div class="operation-step ${stepStatus}">
                            <span class="step-number">${i + 1}</span>
                            <span class="step-name">${step.step}</span>
                            <span class="step-status">[${step.status}]</span>
                            <span class="step-duration">${step.duration_ms}ms</span>
                        </div>
                    `;
                }).join('');
                
                const metadataHTML = operationLog.metadata ? 
                    `<div class="operation-metadata">
                        <strong>Metadata:</strong>
                        <pre class="json-data">${escapeHtml(safeStringify(operationLog.metadata))}</pre>
                    </div>` : '';
                
                const fullHTML = `
                    <div class="debug-pair-header" onclick="toggleDebugPair('${callId}')">
                        <div class="debug-pair-title">
                            🔄 Operation: ${operationName} (${operationLog.protocol})
                            <span class="debug-status ${statusClass}">[${operationLog.status.toUpperCase()}]</span>
                        </div>
                        <div class="debug-pair-meta">
                            <span class="debug-pair-agent">${operationLog.agent_name}</span>
                            <span class="debug-pair-duration">${operationLog.duration_ms}ms</span>
                            <span class="debug-pair-time">${timestamp}</span>
                        </div>
                        <div class="debug-pair-toggle">${isError ? '▲' : '▼'}</div>
                    </div>
                    <div id="${callId}" class="debug-pair-content" style="display: ${isError ? 'block' : 'none'};">
                        <div class="operation-summary">
                            <p><strong>Summary:</strong> ${operationLog.summary}</p>
                            <p><strong>Protocol Steps (${operationLog.step_count}):</strong></p>
                            <div class="operation-steps">
                                ${stepsHTML}
                            </div>
                            ${metadataHTML}
                        </div>
                    </div>
                `;
                
                operationEntry.innerHTML = fullHTML;
                
                // Store entry
                debugEntries.push({
                    type: isError ? 'error' : 'operation',
                    element: operationEntry,
                    timestamp: Date.now(),
                    isError: isError
                });
                
                // Add to current view if matching filter
                const shouldShow = currentDebugTab === 'all' ||
                    (currentDebugTab === 'requests') ||
                    (currentDebugTab === 'responses') ||
                    (currentDebugTab === 'errors' && isError);
                    
                if (shouldShow) {
                    const debugContent = document.getElementById('debug-content');
                    if (debugContent) {
                        debugContent.appendChild(operationEntry);
                    } else {
                        console.log(`❌ displayOperationLog: Could not find debug-content element`);
                    }
                }
            } catch (error) {
                console.error('Error displaying operation log:', error);
            }
        }
        
        function formatTime(timestamp) {
            try {
                if (!timestamp) {
                    return '[No timestamp]';
                }
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) {
                    return '[Invalid timestamp]';
                }
                return date.toLocaleTimeString();
            } catch (error) {
                console.warn('Error formatting timestamp:', timestamp, error);
                return '[Format error]';
            }
        }
        
        function safeStringify(obj) {
            try {
                return JSON.stringify(obj, null, 2);
            } catch (error) {
                return `[Error serializing object: ${error.message}]`;
            }
        }

        function formatErrorMessage(data) {
            // If it's an error object with specific structure, format it nicely
            if (data && typeof data === 'object') {
                // Handle MCP/A2A error format
                if (data.content && Array.isArray(data.content)) {
                    const errorText = data.content
                        .map(c => c.text || c)
                        .join('\n\n');

                    // Try to pretty-print any JSON in the error
                    try {
                        // Check if it contains validation errors
                        if (errorText.includes('validation errors')) {
                            // Split into lines and format
                            const lines = errorText.split('\n');
                            const formatted = lines.map(line => {
                                // Indent field names
                                if (line.match(/^[a-z_]+$/)) {
                                    return `  • ${line}`;
                                }
                                // Indent error details
                                if (line.trim().startsWith('Field required') ||
                                    line.trim().startsWith('type=') ||
                                    line.trim().startsWith('input_value=')) {
                                    return `    ${line.trim()}`;
                                }
                                return line;
                            });
                            return formatted.join('\n');
                        }
                    } catch (e) {
                        // If parsing fails, return original
                    }

                    return errorText;
                }

                // Handle standard error objects
                if (data.error) {
                    return formatErrorMessage(data.error);
                }

                // Handle error with message
                if (data.message) {
                    let result = `Error: ${data.message}`;
                    if (data.code) result = `[${data.code}] ${result}`;
                    if (data.details) {
                        result += `\n\nDetails:\n${safeStringify(data.details)}`;
                    }
                    return result;
                }
            }

            // Fallback to regular stringification
            return safeStringify(data);
        }
        
        function toggleCallDetails(callId) {
            try {
                const detailsElement = document.getElementById(callId);
                if (!detailsElement) {
                    console.warn(`Debug details element not found: ${callId}`);
                    return;
                }
                
                const headerElement = detailsElement.previousElementSibling;
                if (!headerElement) {
                    console.warn(`Header element not found for: ${callId}`);
                    return;
                }
                
                const toggleElement = headerElement.querySelector('.debug-call-toggle');
                if (!toggleElement) {
                    console.warn(`Toggle element not found for: ${callId}`);
                    return;
                }
                
                if (detailsElement.style.display === 'none') {
                    detailsElement.style.display = 'block';
                    toggleElement.textContent = '▲';
                } else {
                    detailsElement.style.display = 'none';
                    toggleElement.textContent = '▼';
                }
            } catch (error) {
                console.error(`Error toggling call details for ${callId}:`, error);
            }
        }
        
        function displayAuthenticLogs(logs, agent) {
            // Group logs by their protocol flow (look for sequences starting with tool calls)
            let callGroups = [];
            let currentGroup = [];
            
            logs.forEach(log => {
                // Start a new group when we see a tool call
                if (log.message && (log.message.includes('Calling tool') || log.message.includes('Calling skill'))) {
                    if (currentGroup.length > 0) {
                        callGroups.push(currentGroup);
                    }
                    currentGroup = [log];
                } else {
                    currentGroup.push(log);
                }
            });
            
            // Add the last group
            if (currentGroup.length > 0) {
                callGroups.push(currentGroup);
            }
            
            // Display each group as a call
            callGroups.forEach((group, groupIndex) => {
                const callId = `call-${Date.now()}-${groupIndex}`;
                const firstLog = group[0];
                const methodName = extractMethodFromLog(firstLog);
                
                // Determine overall status from the group
                let statusClass = 'pending';
                let isError = false;
                let status = 'In Progress';
                
                // Find the final status from the logs
                const errorLog = group.find(log => log.type === 'error');
                const successLog = group.find(log => log.type === 'success');
                
                if (errorLog) {
                    statusClass = 'error';
                    isError = true;
                    status = 'Error';
                } else if (successLog) {
                    statusClass = 'success';
                    status = 'Success';
                }
                
                const callCard = document.createElement('div');
                callCard.className = `debug-call-card ${statusClass}`;
                
                callCard.innerHTML = `
                    <div class="debug-call-header" onclick="toggleCallDetails('${callId}')">
                        <div class="debug-call-title">
                            <span class="debug-call-icon">📞</span>
                            <span class="debug-call-method">Call ${groupIndex + 1}: ${escapeHtml(methodName)}</span>
                            <span class="debug-call-status">[${escapeHtml(status)}]</span>
                        </div>
                        <div class="debug-call-timestamp">${formatTime(firstLog.timestamp)}</div>
                        <div class="debug-call-toggle">▼</div>
                    </div>
                    <div id="${callId}" class="debug-call-details" style="display: none;">
                        ${group.map(log => {
                            const isError = log.type === 'error';
                            const formattedData = log.response ?
                                (isError ? formatErrorMessage(log.response) : safeStringify(log.response)) :
                                '';
                            return `
                            <div class="debug-log-entry ${log.type}">
                                <div class="debug-log-header">
                                    <span class="debug-log-type">${escapeHtml(log.type.toUpperCase())}</span>
                                    <span class="debug-log-time">${formatTime(log.timestamp)}</span>
                                </div>
                                <div class="debug-log-message">${escapeHtml(log.message || 'No message')}</div>
                                ${formattedData ? `<pre class="debug-log-data ${isError ? 'error' : ''}">${escapeHtml(formattedData)}</pre>` : ''}
                            </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                // Store entry in debugEntries for Copy All functionality
                debugEntries.push({
                    type: isError ? 'error' : 'success',
                    title: `Call ${groupIndex + 1}: ${methodName}`,
                    timestamp: firstLog.timestamp,
                    method: methodName,
                    protocol: 'MCP',
                    url: agent?.agent_uri || 'unknown',
                    headers: {},
                    body: group.map(log => `${log.type.toUpperCase()}: ${log.message}`).join('\n'),
                    element: callCard,
                    isError: isError
                });
                
                const debugContent = document.getElementById('debug-content');
                if (debugContent) {
                    debugContent.appendChild(callCard);
                }
            });
        }

        function displayLegacyPairs(pairs, agent) {
            pairs.forEach((pair, pairIndex) => {
                try {
                    const callId = `call-${Date.now()}-${pairIndex}`;
                    const methodName = pair.request ? extractMethodName(pair.request) : extractMethodFromLog(pair.response);
                    
                    // Filter out low-level protocol calls - only show business logic
                    const lowLevelCalls = ['agent-card.json', 'tools/list', 'resources/list', 'prompts/list'];
                    const isLowLevel = lowLevelCalls.some(call => 
                        methodName.includes(call) || 
                        (pair.request && pair.request.url && pair.request.url.includes(call))
                    );
                    
                    if (isLowLevel) {
                        // Cache agent capabilities but don't show in debug
                        if (methodName.includes('agent-card') && pair.response) {
                            const cacheKey = `agent-${agent.id}`;
                            agentCardCache.set(cacheKey, {
                                response: pair.response,
                                timestamp: Date.now()
                            });
                            logEvent('info', `📋 Cached agent capabilities for ${agent.name}`);
                        }
                        return; // Skip displaying this call
                    }
                    
                    const status = pair.response ? pair.response.status : 'No Response';
                    const statusText = pair.response ? pair.response.statusText : '';
                    
                    let statusClass = 'pending';
                    let isError = false;
                    
                    if (pair.response && pair.response.status) {
                        if (pair.response.status >= 200 && pair.response.status < 300) statusClass = 'success';
                        else if (pair.response.status >= 400) statusClass = 'error';
                        isError = pair.response.status >= 400;
                    } else if (pair.response && pair.response.type === 'error') {
                        // Handle error-type logs without HTTP status
                        statusClass = 'error';
                        isError = true;
                    }
                    
                    // Create collapsible pair container
                    const pairEntry = document.createElement('div');
                    pairEntry.className = `debug-pair ${isError ? 'error' : ''}`;
                    
                    const timestamp = new Date().toLocaleTimeString();
                    const contentHTML = createRequestResponseHTML(pair.request, pair.response);
                    
                    const fullHTML = `
                        <div class="debug-pair-header" onclick="toggleDebugPair('${callId}')">
                            <div class="debug-pair-title">
                                📞 Call ${pairIndex + 1}: ${methodName}
                                <span class="debug-status ${statusClass}">[${status}${statusText ? ' ' + statusText : ''}]</span>
                            </div>
                            <div class="debug-pair-time">${timestamp}</div>
                            <div class="debug-pair-toggle">${isError ? '▲' : '▼'}</div>
                        </div>
                        <div id="${callId}" class="debug-pair-content" style="display: ${isError ? 'block' : 'none'};">
                            ${contentHTML}
                        </div>
                    `;
                    
                    pairEntry.innerHTML = fullHTML;
                    
                    // Store entry
                    debugEntries.push({
                        type: isError ? 'error' : 'pair',
                        element: pairEntry,
                        timestamp: Date.now(),
                        isError: isError
                    });
                    
                    // Add to current view if matching filter
                    const shouldShow = currentDebugTab === 'all' ||
                        (currentDebugTab === 'requests' && pair.request) ||
                        (currentDebugTab === 'responses' && pair.response) ||
                        (currentDebugTab === 'errors' && isError);
                        
                    if (shouldShow) {
                        const debugContent = document.getElementById('debug-content');
                        if (debugContent) {
                            debugContent.appendChild(pairEntry);
                        } else {
                            console.log(`❌ displayLegacyPairs: Could not find debug-content element`);
                        }
                    }
                } catch (error) {
                    console.error('Error displaying legacy pair:', error);
                }
            });
        }
        
        // Helper function to safely escape HTML to prevent XSS
        function escapeHtml(text) {
            if (typeof text !== 'string') {
                text = String(text);
            }
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Helper function to safely create HTML with mixed content
        function createSafeHtml(template, data) {
            // Replace placeholders in template with escaped data
            return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
                return escapeHtml(data[key] || '');
            });
        }

        function displayValidationResult(validation, agent) {
            if (!validation) return;
            
            // Create validation entry
            const validationEntry = document.createElement('div');
            validationEntry.className = 'debug-entry validation';
            
            // Determine validation status
            let statusClass = 'unknown';
            let statusText = '?';
            let statusIcon = '⚠️';
            
            if (validation.valid === true) {
                statusClass = 'valid';
                statusText = '✓';
                statusIcon = '✅';
            } else if (validation.valid === false) {
                statusClass = 'invalid';
                statusText = '✗';  
                statusIcon = '❌';
            }
            
            // Create unique ID for this validation entry
            const validationId = `validation-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            // Create validation header with copy button
            const header = document.createElement('div');
            header.className = 'debug-entry-header';
            
            // Create left span with validation info
            const leftSpan = document.createElement('span');
            leftSpan.innerHTML = `${statusIcon} <span class="validation-status ${statusClass}">${statusText}</span> AdCP Validation - `;
            
            const agentNameSpan = document.createElement('span');
            agentNameSpan.textContent = agent.name; // Use textContent for safety
            leftSpan.appendChild(agentNameSpan);
            
            if (validation.toolName) {
                const toolSpan = document.createElement('span');
                toolSpan.textContent = ` (${validation.toolName})`;
                leftSpan.appendChild(toolSpan);
            }
            
            // Create right span with copy button and timestamp
            const rightSpan = document.createElement('span');
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-debug-btn';
            copyButton.setAttribute('onclick', `copyValidationDebugInfo('${validationId}')`);
            copyButton.setAttribute('title', 'Copy debug information');
            copyButton.textContent = '📋 Copy Debug Info';
            
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'debug-timestamp';
            timestampSpan.textContent = new Date().toLocaleTimeString();
            
            rightSpan.appendChild(copyButton);
            rightSpan.appendChild(timestampSpan);
            
            header.appendChild(leftSpan);
            header.appendChild(rightSpan);
            
            // Create validation details
            const details = document.createElement('div');
            details.className = 'validation-details';
            details.id = validationId;
            
            // Add validation context info
            if (validation.toolName || validation.protocol || validation.expectedSchema) {
                const contextDiv = document.createElement('div');
                contextDiv.className = 'validation-context';
                
                const contextTitle = document.createElement('strong');
                contextTitle.textContent = 'Context:';
                contextDiv.appendChild(contextTitle);
                contextDiv.appendChild(document.createElement('br'));
                
                if (validation.toolName) {
                    const toolText = document.createElement('span');
                    toolText.textContent = `Tool: ${validation.toolName}`;
                    contextDiv.appendChild(toolText);
                    contextDiv.appendChild(document.createElement('br'));
                }
                
                if (validation.protocol) {
                    const protocolText = document.createElement('span');
                    protocolText.textContent = `Protocol: ${validation.protocol}`;
                    contextDiv.appendChild(protocolText);
                    contextDiv.appendChild(document.createElement('br'));
                }
                
                if (validation.expectedSchema) {
                    const schemaText = document.createElement('span');
                    schemaText.textContent = 'Expected Schema: ';
                    const schemaLink = document.createElement('a');
                    schemaLink.href = validation.expectedSchema;
                    schemaLink.target = '_blank';
                    schemaLink.rel = 'noopener noreferrer'; // Security best practice
                    schemaLink.textContent = validation.expectedSchema;
                    schemaText.appendChild(schemaLink);
                    contextDiv.appendChild(schemaText);
                    contextDiv.appendChild(document.createElement('br'));
                }
                
                details.appendChild(contextDiv);
            }
            
            // Display main summary
            if (validation.summary) {
                const summary = document.createElement('div');
                summary.className = 'validation-summary';
                summary.textContent = validation.summary;
                details.appendChild(summary);
            }
            
            // Handle wrong response type errors (e.g., got products when expecting media buy)
            if (validation.error && validation.error.includes('Expected') && validation.parsedResponse) {
                const wrongTypeDiv = document.createElement('div');
                wrongTypeDiv.className = 'validation-error validation-wrong-type';
                
                const warningBox = document.createElement('div');
                warningBox.style.cssText = 'background: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 4px; margin: 8px 0;';
                
                const warningTitle = document.createElement('strong');
                warningTitle.style.color = '#856404';
                warningTitle.textContent = '⚠️ Wrong Response Type';
                warningBox.appendChild(warningTitle);
                warningBox.appendChild(document.createElement('br'));
                
                const errorMessage = document.createElement('div');
                errorMessage.style.cssText = 'margin-top: 4px; color: #856404;';
                errorMessage.textContent = validation.error;
                warningBox.appendChild(errorMessage);
                
                const responseDetails = document.createElement('details');
                responseDetails.style.cssText = 'margin-top: 8px;';
                
                const summary = document.createElement('summary');
                summary.style.cssText = 'cursor: pointer; color: #856404;';
                const summaryTitle = document.createElement('strong');
                summaryTitle.textContent = 'Actual Response Structure:';
                summary.appendChild(summaryTitle);
                responseDetails.appendChild(summary);
                
                const pre = document.createElement('pre');
                pre.style.cssText = 'background: #f8f9fa; padding: 8px; margin-top: 4px; border-radius: 4px; overflow-x: auto; color: #333;';
                pre.textContent = JSON.stringify(validation.parsedResponse, null, 2);
                responseDetails.appendChild(pre);
                
                warningBox.appendChild(responseDetails);
                wrongTypeDiv.appendChild(warningBox);
                details.appendChild(wrongTypeDiv);
            }
            
            // Display validation stats for product arrays
            if (validation.totalProducts !== undefined) {
                const statsDiv = document.createElement('div');
                statsDiv.innerHTML = `
                    <strong>Product Validation:</strong><br>
                    Valid: ${validation.validProducts}/${validation.totalProducts} products<br>
                    ${validation.invalidProducts > 0 ? `<span style="color: #ff4444;">Invalid: ${validation.invalidProducts}</span>` : ''}
                `;
                details.appendChild(statsDiv);
                
                // Display detailed per-product errors
                if (validation.results && validation.results.length > 0) {
                    const invalidProducts = validation.results.filter(r => !r.valid);
                    
                    if (invalidProducts.length > 0) {
                        const productErrorsDiv = document.createElement('div');
                        productErrorsDiv.className = 'validation-product-errors';
                        productErrorsDiv.innerHTML = '<strong style="color: #ff4444;">Product-Specific Errors:</strong>';
                        
                        invalidProducts.forEach((productResult, index) => {
                            const productDiv = document.createElement('div');
                            productDiv.className = 'validation-product-error';
                            productDiv.style.cssText = 'border-left: 3px solid #ff4444; padding-left: 10px; margin: 8px 0; background: #fdf2f2;';
                            
                            let productHtml = `
                                <div style="font-weight: bold; color: #c53030;">
                                    Product: ${productResult.product_id || `#${productResult.index || index}`}
                                </div>
                            `;
                            
                            // Show missing required fields
                            if (productResult.summary && productResult.summary.missingRequired && productResult.summary.missingRequired.length > 0) {
                                productHtml += `
                                    <div style="margin-top: 4px;">
                                        <strong style="color: #e53e3e;">Missing Required Fields:</strong>
                                        <ul style="margin: 2px 0; padding-left: 20px;">
                                `;
                                productResult.summary.missingRequired.forEach(missing => {
                                    productHtml += `<li style="color: #c53030;">${missing.field || missing.message}</li>`;
                                });
                                productHtml += `</ul></div>`;
                            }
                            
                            // Show type errors
                            if (productResult.summary && productResult.summary.typeErrors && productResult.summary.typeErrors.length > 0) {
                                productHtml += `
                                    <div style="margin-top: 4px;">
                                        <strong style="color: #e53e3e;">Type Errors:</strong>
                                        <ul style="margin: 2px 0; padding-left: 20px;">
                                `;
                                productResult.summary.typeErrors.forEach(typeError => {
                                    productHtml += `<li style="color: #c53030;">
                                        Field: ${typeError.field} - Expected: ${typeError.expected}, Got: ${typeError.actual}
                                    </li>`;
                                });
                                productHtml += `</ul></div>`;
                            }
                            
                            // Show format errors
                            if (productResult.summary && productResult.summary.formatErrors && productResult.summary.formatErrors.length > 0) {
                                productHtml += `
                                    <div style="margin-top: 4px;">
                                        <strong style="color: #e53e3e;">Format Errors:</strong>
                                        <ul style="margin: 2px 0; padding-left: 20px;">
                                `;
                                productResult.summary.formatErrors.forEach(formatError => {
                                    productHtml += `<li style="color: #c53030;">
                                        Field: ${formatError.field} - ${formatError.message}
                                    </li>`;
                                });
                                productHtml += `</ul></div>`;
                            }
                            
                            // Show raw validation errors if available
                            if (productResult.errors && productResult.errors.length > 0) {
                                productHtml += `
                                    <details style="margin-top: 4px;">
                                        <summary style="cursor: pointer; color: #c53030;"><strong>Raw Validation Errors:</strong></summary>
                                        <ul style="margin: 2px 0; padding-left: 20px;">
                                `;
                                productResult.errors.forEach(error => {
                                    productHtml += `<li style="color: #c53030; font-size: 12px;">
                                        ${error.instancePath || 'root'}: ${error.message}
                                    </li>`;
                                });
                                productHtml += `</ul></details>`;
                            }
                            
                            productDiv.innerHTML = productHtml;
                            productErrorsDiv.appendChild(productDiv);
                        });
                        
                        details.appendChild(productErrorsDiv);
                    }
                }
            }
            
            // Display top-level validation errors if present (for non-product responses)
            if (validation.errors && validation.errors.length > 0 && !validation.results) {
                const errorsHeader = document.createElement('div');
                errorsHeader.innerHTML = '<strong>Schema Violations:</strong>';
                details.appendChild(errorsHeader);
                
                validation.errors.forEach(error => {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'validation-error';
                    errorDiv.innerHTML = `
                        <div><strong>Field:</strong> ${error.instancePath || 'root'}</div>
                        <div><strong>Error:</strong> ${error.message}</div>
                        ${error.keyword ? `<div><strong>Rule:</strong> ${error.keyword}</div>` : ''}
                    `;
                    details.appendChild(errorDiv);
                });
            }
            
            // Display error summary if present (for non-product responses)
            if (validation.summary && validation.summary.missingRequired && validation.summary.missingRequired.length > 0 && !validation.results) {
                const missingHeader = document.createElement('div');
                missingHeader.innerHTML = '<strong>Missing Required Fields:</strong>';
                details.appendChild(missingHeader);
                
                validation.summary.missingRequired.forEach(missing => {
                    const missingDiv = document.createElement('div');
                    missingDiv.className = 'validation-error';
                    missingDiv.textContent = missing.message || missing.field;
                    details.appendChild(missingDiv);
                });
            }
            
            // Add general error details if validation failed
            if (validation.error && !validation.error.includes('Expected')) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'validation-error';
                errorDiv.innerHTML = `<strong>Validation Error:</strong> ${validation.error}`;
                details.appendChild(errorDiv);
            }
            
            // Store validation data for copy function
            validationEntry.validationData = validation;
            validationEntry.agentData = agent;
            
            validationEntry.appendChild(header);
            validationEntry.appendChild(details);
            
            // Add to debug entries and display
            debugEntries.push({
                element: validationEntry,
                type: 'validation',
                timestamp: Date.now(),
                agent: agent,
                validationId: validationId
            });
            
            // Show in current view if validation tab is active or show all
            if (currentDebugTab === 'all' || currentDebugTab === 'validation') {
                const debugContent = document.getElementById('debug-content');
                if (debugContent) {
                    // Clear "waiting" message if first entry
                    if (debugContent.innerHTML.includes('Waiting for agent communication')) {
                        debugContent.innerHTML = '';
                    }
                    debugContent.appendChild(validationEntry);
                    debugContent.scrollTop = debugContent.scrollHeight;
                }
            }
        }
        
        // Copy validation debug information to clipboard
        function copyValidationDebugInfo(validationId) {
            try {
                const validationEntry = debugEntries.find(entry => entry.validationId === validationId);
                if (!validationEntry) {
                    alert('Validation data not found');
                    return;
                }
                
                const validation = validationEntry.element.validationData;
                const agent = validationEntry.element.agentData;
                
                let debugReport = `# AdCP Validation Error Report\n\n`;
                debugReport += `**Generated:** ${new Date().toISOString()}\n`;
                debugReport += `**Agent:** ${agent.name} (${agent.id})\n`;
                debugReport += `**Protocol:** ${validation.protocol || 'unknown'}\n`;
                debugReport += `**Tool Called:** ${validation.toolName || 'unknown'}\n`;
                debugReport += `**Status:** ${validation.valid ? 'VALID' : 'INVALID'}\n\n`;
                
                if (validation.expectedSchema) {
                    debugReport += `**Expected Schema:** ${validation.expectedSchema}\n\n`;
                }
                
                debugReport += `## Summary\n${validation.summary || 'No summary available'}\n\n`;
                
                if (validation.error) {
                    debugReport += `## Error\n${validation.error}\n\n`;
                }
                
                // Add request information if available
                if (validation.originalResponse) {
                    debugReport += `## Original Response\n\`\`\`json\n${JSON.stringify(validation.originalResponse, null, 2)}\n\`\`\`\n\n`;
                }
                
                if (validation.parsedResponse) {
                    debugReport += `## Parsed Response\n\`\`\`json\n${JSON.stringify(validation.parsedResponse, null, 2)}\n\`\`\`\n\n`;
                }
                
                // Add product-specific errors if present
                if (validation.results && validation.results.length > 0) {
                    const invalidProducts = validation.results.filter(r => !r.valid);
                    if (invalidProducts.length > 0) {
                        debugReport += `## Product Validation Errors\n\n`;
                        
                        invalidProducts.forEach((productResult, index) => {
                            debugReport += `### Product: ${productResult.product_id || `#${productResult.index || index}`}\n\n`;
                            
                            if (productResult.summary) {
                                if (productResult.summary.missingRequired && productResult.summary.missingRequired.length > 0) {
                                    debugReport += `**Missing Required Fields:**\n`;
                                    productResult.summary.missingRequired.forEach(missing => {
                                        debugReport += `- ${missing.field || missing.message}\n`;
                                    });
                                    debugReport += `\n`;
                                }
                                
                                if (productResult.summary.typeErrors && productResult.summary.typeErrors.length > 0) {
                                    debugReport += `**Type Errors:**\n`;
                                    productResult.summary.typeErrors.forEach(typeError => {
                                        debugReport += `- Field: ${typeError.field} - Expected: ${typeError.expected}, Got: ${typeError.actual}\n`;
                                    });
                                    debugReport += `\n`;
                                }
                                
                                if (productResult.summary.formatErrors && productResult.summary.formatErrors.length > 0) {
                                    debugReport += `**Format Errors:**\n`;
                                    productResult.summary.formatErrors.forEach(formatError => {
                                        debugReport += `- Field: ${formatError.field} - ${formatError.message}\n`;
                                    });
                                    debugReport += `\n`;
                                }
                            }
                            
                            if (productResult.errors && productResult.errors.length > 0) {
                                debugReport += `**Raw Validation Errors:**\n`;
                                productResult.errors.forEach(error => {
                                    debugReport += `- ${error.instancePath || 'root'}: ${error.message}\n`;
                                });
                                debugReport += `\n`;
                            }
                        });
                    }
                }
                
                // Add top-level errors for non-product responses
                if (validation.errors && validation.errors.length > 0 && !validation.results) {
                    debugReport += `## Schema Violations\n\n`;
                    validation.errors.forEach(error => {
                        debugReport += `- **Field:** ${error.instancePath || 'root'}\n`;
                        debugReport += `  **Error:** ${error.message}\n`;
                        if (error.keyword) {
                            debugReport += `  **Rule:** ${error.keyword}\n`;
                        }
                        debugReport += `\n`;
                    });
                }
                
                debugReport += `\n---\n*Generated by AdCP Sales Agent Debugging Interface*`;
                
                // Copy to clipboard
                navigator.clipboard.writeText(debugReport).then(() => {
                    // Show success feedback
                    const button = document.querySelector(`button[onclick="copyValidationDebugInfo('${validationId}')"]`);
                    if (button) {
                        const originalText = button.textContent;
                        button.textContent = '✅ Copied!';
                        button.style.background = '#10b981';
                        button.style.color = 'white';
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = '';
                            button.style.color = '';
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Failed to copy to clipboard:', err);
                    alert('Failed to copy to clipboard. Please copy manually from browser console.');
                    console.log('Debug Report:', debugReport);
                });
            } catch (error) {
                console.error('Error generating debug info:', error);
                alert('Error generating debug information');
            }
        }
        
        function groupLogsIntoPairs(logs) {
            const pairs = [];
            let currentRequest = null;
            
            for (const log of logs) {
                if (log.type === 'request') {
                    // If we have a pending request, create a pair with no response
                    if (currentRequest) {
                        pairs.push({ request: currentRequest, response: null });
                    }
                    currentRequest = log;
                } else if (log.type === 'response' && currentRequest) {
                    // Pair this response with the current request
                    pairs.push({ request: currentRequest, response: log });
                    currentRequest = null;
                } else if (log.type === 'response') {
                    // Response without a request (shouldn't happen, but handle it)
                    pairs.push({ request: null, response: log });
                } else if (log.type === 'error') {
                    // Handle error logs as standalone entries (treat as response without request)
                    pairs.push({ request: null, response: log });
                } else {
                    // Handle any other log types (info, debug, etc.) as standalone entries
                    pairs.push({ request: null, response: log });
                }
            }
            
            // Handle any remaining unpaired request
            if (currentRequest) {
                pairs.push({ request: currentRequest, response: null });
            }
            
            return pairs;
        }
        
        function extractMethodFromLog(log) {
            if (!log || !log.message) {
                return 'System Log';
            }
            
            // Extract method name from messages like "MCP: Calling tool get_products with args: ..."
            // or "A2A: Calling skill get_products with parameters: ..."
            const mcpMatch = log.message.match(/MCP: Calling tool (\w+)/);
            if (mcpMatch) {
                return mcpMatch[1];
            }
            
            const a2aMatch = log.message.match(/A2A: Calling skill (\w+)/);
            if (a2aMatch) {
                return a2aMatch[1];
            }
            
            // For response messages, try to infer from protocol type
            if (log.message.includes('MCP:')) {
                return 'MCP Response';
            }
            if (log.message.includes('A2A:')) {
                return 'A2A Response';
            }
            
            return 'System Log';
        }

        function extractMethodName(request) {
            if (!request) {
                return 'Unknown';
            }
            
            // Direct method field (for our debug logs structure)
            if (request.method) {
                return request.method;
            }
            
            // Try to extract method from JSON-RPC body
            if (request.body) {
                try {
                    const body = typeof request.body === 'string' ? JSON.parse(request.body) : request.body;
                    
                    if (body.method) {
                        // For MCP tool calls, show tool name instead of generic "tools/call"
                        if (body.method === 'tools/call' && body.params && body.params.name) {
                            return `${body.params.name} (MCP Tool)`;
                        }
                        return body.method;
                    }
                    // Check if body has tool field (for A2A requests)
                    if (body.tool) {
                        return body.tool;
                    }
                } catch (e) {
                    // Silently handle parse errors
                }
            }
            
            // Fall back to URL path
            if (request.url) {
                try {
                    const url = new URL(request.url);
                    const pathParts = url.pathname.split('/').filter(Boolean);
                    return pathParts[pathParts.length - 1] || 'HTTP Request';
                } catch (e) {
                    // URL parsing failed, continue
                }
            }
            
            return 'Unknown';
        }
        
        function createRequestResponseHTML(request, response) {
            let html = '';
            
            // Create full data object for copying
            const fullData = {
                request: request || null,
                response: response || null,
                timestamp: new Date().toISOString()
            };
            const fullDataJson = JSON.stringify(fullData, null, 2);
            
            // Add Copy All button at the top - store data in a global variable to avoid inline encoding issues
            const copyAllId = 'copy-all-' + Date.now();
            window[copyAllId] = fullDataJson;
            html += `
                <div style="text-align: right; margin-bottom: 10px;">
                    <button class="debug-copy-btn" style="background: #28a745; padding: 6px 12px;" onclick="copyDirectContent('${copyAllId}')">📋 Copy All</button>
                </div>
            `;
            
            // Request section
            if (request) {
                html += `
                    <div class="debug-section">
                        <h4>📤 Request</h4>
                        <div><strong>Method:</strong> ${request.method || 'N/A'}</div>
                        <div><strong>URL:</strong> ${request.url || 'N/A'}</div>
                `;
                
                if (request.headers && Object.keys(request.headers).length > 0) {
                    const headersJson = JSON.stringify(request.headers, null, 2);
                    const headersId = 'headers-' + Date.now() + '-' + Math.random();
                    window[headersId] = headersJson;
                    html += `
                        <div style="margin-top: 8px;">
                            <strong>Headers:</strong>
                            <button class="debug-copy-btn" onclick="copyDirectContent('${headersId}')">Copy</button>
                            <div class="debug-json">
                                <pre>${escapeHtml(headersJson)}</pre>
                            </div>
                        </div>
                    `;
                }
                
                if (request.body) {
                    let bodyContent = request.body;
                    if (typeof bodyContent === 'string') {
                        try {
                            const parsed = JSON.parse(bodyContent);
                            bodyContent = JSON.stringify(parsed, null, 2);
                        } catch (e) {
                            // Keep as string
                        }
                    } else {
                        bodyContent = JSON.stringify(bodyContent, null, 2);
                    }
                    
                    const bodyId = 'req-body-' + Date.now() + '-' + Math.random();
                    window[bodyId] = bodyContent;
                    html += `
                        <div style="margin-top: 8px;">
                            <strong>Body:</strong>
                            <button class="debug-copy-btn" onclick="copyDirectContent('${bodyId}')">Copy</button>
                            <div class="debug-json">
                                <pre>${escapeHtml(bodyContent)}</pre>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
            }
            
            // Response section
            if (response) {
                // All responses should be HTTP response objects with status, headers, body
                let statusClass = 'pending';
                if (response.status >= 200 && response.status < 300) statusClass = 'success';
                else if (response.status >= 400) statusClass = 'error';
                
                html += `
                    <div class="debug-section">
                        <h4>📥 Response</h4>
                        <div>
                            <strong>Status:</strong>
                            <span class="debug-status ${statusClass}">${response.status} ${response.statusText || ''}</span>
                        </div>
                `;
                
                // For HTTP responses, handle headers and body
                if (response.headers && Object.keys(response.headers).length > 0) {
                    const headersJson = JSON.stringify(response.headers, null, 2);
                    const respHeadersId = 'resp-headers-' + Date.now() + '-' + Math.random();
                    window[respHeadersId] = headersJson;
                    html += `
                        <div style="margin-top: 8px;">
                            <strong>Headers:</strong>
                            <button class="debug-copy-btn" onclick="copyDirectContent('${respHeadersId}')">Copy</button>
                            <div class="debug-json">
                                <pre>${escapeHtml(headersJson)}</pre>
                            </div>
                        </div>
                    `;
                }
                
                if (response.body) {
                    let bodyContent = response.body;
                    let unwrappedResponse = null;
                    let rawErrorMessage = null;
                    let isError = response.status >= 400;

                    if (typeof bodyContent === 'string') {
                        try {
                            const parsed = JSON.parse(bodyContent);

                            // Use formatErrorMessage for errors
                            if (isError) {
                                bodyContent = formatErrorMessage(parsed);
                            } else {
                                bodyContent = JSON.stringify(parsed, null, 2);
                            }

                            // Check for embedded MCP response in error message
                            if (parsed.error && parsed.error.message && parsed.error.message.includes('HTTP')) {
                                const match = parsed.error.message.match(/HTTP \d+\): (.+)$/);
                                if (match) {
                                    try {
                                        unwrappedResponse = JSON.parse(match[1]);
                                        rawErrorMessage = bodyContent; // Save the wrapped version
                                    } catch (e) {
                                        // Not valid JSON
                                    }
                                }
                            }
                        } catch (e) {
                            // Keep as string
                        }
                    } else if (typeof bodyContent === 'object') {
                        // Use formatErrorMessage for error objects
                        if (isError) {
                            bodyContent = formatErrorMessage(bodyContent);
                        } else {
                            bodyContent = JSON.stringify(bodyContent, null, 2);
                        }
                    }

                    // Show unwrapped response as primary body if available
                    if (unwrappedResponse) {
                        const unwrappedContent = formatErrorMessage(unwrappedResponse);
                        const unwrappedId = 'unwrapped-' + Date.now() + '-' + Math.random();
                        window[unwrappedId] = unwrappedContent;
                        html += `
                            <div style="margin-top: 8px;">
                                <strong>Body:</strong>
                                <button class="debug-copy-btn" onclick="copyDirectContent('${unwrappedId}')">Copy</button>
                                <div class="debug-json error" style="background: rgba(239, 68, 68, 0.1); border-color: rgba(239, 68, 68, 0.3);">
                                    <pre style="color: #dc2626;">${escapeHtml(unwrappedContent)}</pre>
                                </div>
                            </div>
                        `;

                        // Show wrapped version as collapsible raw details
                        const rawErrorId = 'raw-error-' + Date.now() + '-' + Math.random();
                        window[rawErrorId] = rawErrorMessage;
                        html += `
                            <div style="margin-top: 12px; border-top: 1px solid #444; padding-top: 8px;">
                                <details>
                                    <summary style="cursor: pointer; color: #888; font-size: 0.9em;">
                                        <strong>📄 Raw Error Details</strong>
                                    </summary>
                                    <div style="margin-top: 8px;">
                                        <button class="debug-copy-btn" onclick="copyDirectContent('${rawErrorId}')">Copy</button>
                                        <div class="debug-json">
                                            <pre>${escapeHtml(rawErrorMessage)}</pre>
                                        </div>
                                    </div>
                                </details>
                            </div>
                        `;
                    } else {
                        // Show original body content if no unwrapped response
                        const bodyContentId = 'body-content-' + Date.now() + '-' + Math.random();
                        window[bodyContentId] = bodyContent;
                        const errorClass = isError ? 'error' : '';
                        const errorStyle = isError ? 'background: rgba(239, 68, 68, 0.1); border-color: rgba(239, 68, 68, 0.3);' : '';
                        const errorTextStyle = isError ? 'color: #dc2626;' : '';
                        html += `
                            <div style="margin-top: 8px;">
                                <strong>Body:</strong>
                                <button class="debug-copy-btn" onclick="copyDirectContent('${bodyContentId}')">Copy</button>
                                <div class="debug-json ${errorClass}" style="${errorStyle}">
                                    <pre style="${errorTextStyle}">${escapeHtml(bodyContent)}</pre>
                                </div>
                            </div>
                        `;
                    }
                }
                
                html += '</div>'; // Close debug-section for HTTP response
            } else {
                html += `
                    <div class="debug-section">
                        <h4>📥 Response</h4>
                        <div style="color: #999; font-style: italic;">No response received</div>
                    </div>
                `;
            }
            
            return html;
        }
        
        function toggleDebugPair(callId) {
            const content = document.getElementById(callId);
            const header = content.previousElementSibling;
            const toggle = header.querySelector('.debug-pair-toggle');
            
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                toggle.textContent = '▲';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▼';
            }
        }
        
        function copyToClipboard(base64Content) {
            try {
                // Try decoding the base64 content
                const content = decodeURIComponent(atob(base64Content));
                
                // Use the more reliable writeText method with fallback
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(content).then(() => {
                        // Show brief confirmation
                        const btn = event.target;
                        const originalText = btn.textContent;
                        btn.textContent = '✓ Copied';
                        setTimeout(() => {
                            btn.textContent = originalText;
                        }, 2000);
                    }).catch(err => {
                        console.error('Clipboard API failed:', err);
                        // Fallback to older method
                        fallbackCopyToClipboard(content);
                    });
                } else {
                    // Browser doesn't support clipboard API
                    fallbackCopyToClipboard(content);
                }
            } catch (error) {
                console.error('Failed to decode clipboard content:', error);
                // Try to extract the content directly if base64 decode fails
                try {
                    fallbackCopyToClipboard(base64Content);
                } catch (fallbackError) {
                    console.error('Fallback copy also failed:', fallbackError);
                    alert('Failed to copy to clipboard. Please check browser permissions.');
                }
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Create a temporary textarea element
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.top = "-9999px";
            textArea.style.left = "-9999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    const btn = event.target;
                    if (btn) {
                        const originalText = btn.textContent;
                        btn.textContent = '✓ Copied';
                        setTimeout(() => {
                            btn.textContent = originalText;
                        }, 2000);
                    }
                } else {
                    throw new Error('execCommand copy failed');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert('Failed to copy to clipboard. Please copy manually.');
            } finally {
                document.body.removeChild(textArea);
            }
        }
        
        function copyDirectContent(globalVarName) {
            const content = window[globalVarName];
            if (!content) {
                console.error('Content not found for:', globalVarName);
                alert('Content not found to copy');
                return;
            }
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(content).then(() => {
                    // Show brief confirmation
                    const btn = event.target;
                    if (btn) {
                        const originalText = btn.textContent;
                        btn.textContent = '✓ Copied';
                        setTimeout(() => {
                            btn.textContent = originalText;
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    // Fallback to older method
                    fallbackCopyToClipboard(content);
                });
            } else {
                // Browser doesn't support clipboard API
                fallbackCopyToClipboard(content);
            }
            
            // Clean up the global variable after copying
            setTimeout(() => {
                delete window[globalVarName];
            }, 5000);
        }
        
        // ============================================================================
        // Event Logging
        // ============================================================================
        
        function logEvent(type, message) {
            eventLogCount++;
            const timestamp = new Date().toLocaleTimeString();
            const eventLog = document.getElementById('event-log');
            
            const entry = document.createElement('div');
            entry.className = 'event-entry';
            entry.innerHTML = `
                <span class="timestamp">${timestamp}</span>
                <span class="event-type">[${type.toUpperCase()}]</span>
                ${message}
            `;
            
            // Add color based on event type
            switch (type.toLowerCase()) {
                case 'success':
                    entry.style.color = '#28a745';
                    break;
                case 'error':
                    entry.style.color = '#dc3545';
                    break;
                case 'warning':
                    entry.style.color = '#ffc107';
                    break;
                case 'sse':
                    entry.style.color = '#17a2b8';
                    break;
                case 'test':
                    entry.style.color = '#6f42c1';
                    break;
                default:
                    entry.style.color = '#6c757d';
            }
            
            eventLog.appendChild(entry);
            
            // Auto-scroll to bottom
            eventLog.scrollTop = eventLog.scrollHeight;
            
            // Limit log entries to prevent memory issues
            if (eventLog.children.length > 100) {
                eventLog.removeChild(eventLog.firstChild);
            }
        }
        
        function clearEventLog() {
            const eventLog = document.getElementById('event-log');
            eventLog.innerHTML = `
                <div class="event-entry">
                    <span class="timestamp">--:--:--</span>
                    <span class="event-type">[SYSTEM]</span>
                    Event log cleared
                </div>
            `;
            eventLogCount = 0;
        }

        // ============================================================================
        // Agent Management Functions (keeping from original)
        // ============================================================================
        
        // Toggle add agent form visibility
        function toggleAddAgent() {
            const form = document.getElementById('add-agent-form');
            const button = document.getElementById('add-toggle-btn');
            
            if (form.style.display === 'none' || form.style.display === '') {
                form.style.display = 'block';
                button.textContent = '❌ Cancel';
            } else {
                form.style.display = 'none';
                button.textContent = '➕ Add Agent';
                // Clear form when hiding it
                clearAgentForm();
            }
        }
        
        // Switch between manual and JSON input methods
        function switchInputMethod(method) {
            const manualTab = document.getElementById('manual-tab');
            const jsonTab = document.getElementById('json-tab');
            const manualEntry = document.getElementById('manual-entry');
            const jsonEntry = document.getElementById('json-entry');
            
            if (method === 'manual') {
                // Activate manual tab
                manualTab.style.background = '#1a4d3a';
                jsonTab.style.background = '#6c757d';
                manualEntry.style.display = 'block';
                jsonEntry.style.display = 'none';
            } else {
                // Activate JSON tab
                manualTab.style.background = '#6c757d';
                jsonTab.style.background = '#1a4d3a';
                manualEntry.style.display = 'none';
                jsonEntry.style.display = 'block';
            }
        }
        
        // Add a new agent
        function addAgent() {
            // Check which input method is currently active
            const manualEntry = document.getElementById('manual-entry');
            const jsonEntry = document.getElementById('json-entry');
            
            let agent;
            
            if (manualEntry.style.display !== 'none') {
                // Manual entry mode
                agent = createAgentFromManualInput();
            } else {
                // JSON entry mode
                agent = createAgentFromJsonInput();
            }
            
            if (!agent) {
                return; // Error already shown to user
            }
            
            agents.push(agent);
            updateAgentSelector();
            saveCustomAgentsToStorage();
            
            // Clear form and hide it
            clearAgentForm();
            toggleAddAgent();
            
            // Don't auto-select agent - user should explicitly choose
            // document.getElementById('agent-selector').value = agent.id;
            logEvent('success', `Agent added: ${agent.name}`);
        }
        
        // Create agent from manual form input
        function createAgentFromManualInput() {
            const url = document.getElementById('agent-url').value.trim();
            const protocol = document.getElementById('protocol').value;
            const authToken = document.getElementById('auth-token').value.trim();
            const name = document.getElementById('agent-name').value.trim() || 'Unnamed Agent';
            
            if (!url) {
                alert('Please enter an agent URL');
                return null;
            }
            
            try {
                new URL(url); // Validate URL
            } catch (e) {
                alert('Please enter a valid URL');
                return null;
            }
            
            return {
                id: `custom-${Date.now()}`,
                name: name,
                agent_uri: url,
                protocol: protocol,
                auth_token_env: authToken,
                requiresAuth: !!authToken
            };
        }
        
        // Create agent from JSON input
        function createAgentFromJsonInput() {
            const jsonText = document.getElementById('agent-json').value.trim();
            
            if (!jsonText) {
                alert('Please enter agent configuration JSON');
                return null;
            }
            
            let config;
            try {
                config = JSON.parse(jsonText);
            } catch (e) {
                alert('Invalid JSON format. Please check your syntax.');
                return null;
            }
            
            // Validate required fields
            if (!config.agent_uri && !config.url) {
                alert('JSON must include either "agent_uri" or "url" field');
                return null;
            }
            
            if (!config.protocol) {
                alert('JSON must include "protocol" field (either "mcp" or "a2a")');
                return null;
            }
            
            if (!['mcp', 'a2a'].includes(config.protocol)) {
                alert('Protocol must be either "mcp" or "a2a"');
                return null;
            }
            
            // Extract URL (support both agent_uri and url fields)
            const url = config.agent_uri || config.url;
            
            try {
                new URL(url); // Validate URL
            } catch (e) {
                alert('Please provide a valid URL in the JSON');
                return null;
            }
            
            return {
                id: `custom-${Date.now()}`,
                name: config.name || 'Imported Agent',
                agent_uri: url,
                protocol: config.protocol,
                auth_token_env: config.auth_token_env || config.auth_token || '',
                requiresAuth: !!(config.auth_token_env || config.auth_token)
            };
        }
        
        // Clear all form inputs
        function clearAgentForm() {
            // Manual form fields
            document.getElementById('agent-url').value = '';
            document.getElementById('auth-token').value = '';
            document.getElementById('agent-name').value = '';
            document.getElementById('protocol').value = 'mcp';
            
            // JSON form field
            document.getElementById('agent-json').value = '';
            
            // Reset to manual tab
            switchInputMethod('manual');
        }
        
        // Local Storage Functions
        function saveCustomAgentsToStorage() {
            try {
                // Only save custom agents (those with IDs starting with 'custom-')
                const customAgents = agents.filter(agent => agent.id.startsWith('custom-'));
                localStorage.setItem(CUSTOM_AGENTS_STORAGE_KEY, JSON.stringify(customAgents));
                logEvent('info', `Saved ${customAgents.length} custom agents to local storage`);
            } catch (error) {
                logEvent('error', `Error saving custom agents to storage: ${error.message}`);
            }
        }
        
        function loadCustomAgentsFromStorage() {
            try {
                const stored = localStorage.getItem(CUSTOM_AGENTS_STORAGE_KEY);
                if (stored) {
                    const customAgents = JSON.parse(stored);
                    if (Array.isArray(customAgents)) {
                        // Merge custom agents with API agents
                        const customIds = customAgents.map(a => a.id);
                        agents = agents.filter(agent => !customIds.includes(agent.id));
                        agents = [...agents, ...customAgents];
                        updateAgentSelector();
                        logEvent('info', `Loaded ${customAgents.length} custom agents from local storage`);
                    }
                }
            } catch (error) {
                logEvent('error', `Error loading custom agents from storage: ${error.message}`);
            }
        }
        
        function clearCustomAgentsFromStorage() {
            if (confirm('Are you sure you want to clear all saved custom agents? This cannot be undone.')) {
                try {
                    localStorage.removeItem(CUSTOM_AGENTS_STORAGE_KEY);
                    // Remove custom agents from memory
                    agents = agents.filter(agent => !agent.id.startsWith('custom-'));
                    updateAgentSelector();
                    logEvent('warning', 'Custom agents have been cleared from storage');
                } catch (error) {
                    logEvent('error', `Error clearing custom agents from storage: ${error.message}`);
                }
            }
        }
        
        async function executeToolTest() {
            const agentId = document.getElementById('agent-selector').value;
            const toolName = document.getElementById('tool-selector').value;
            
            if (!agentId) {
                alert('Please select an agent first');
                return;
            }
            
            if (!toolName) {
                alert('Please select a tool first');
                return;
            }
            
            if (!validateParams()) {
                return;
            }
            
            const params = collectParams();
            const agent = agents.find(a => a.id === agentId);
            
            if (!agent) {
                alert('Agent not found');
                return;
            }
            
            // Show loading state
            const resultsDiv = document.getElementById('tool-results');
            resultsDiv.innerHTML = '<div class="loading-spinner"></div> Executing tool...';
            
            try {
                // Execute tool based on protocol
                let result;
                if (agent.protocol === 'mcp') {
                    result = await executeMCPTool(agent, toolName, params);
                } else if (agent.protocol === 'a2a') {
                    result = await executeA2ATool(agent, toolName, params);
                } else {
                    throw new Error(`Unsupported protocol: ${agent.protocol}`);
                }
                
                // Store result in data chain for future use
                storeResultInChain(toolName, result);
                
                // Display results
                showToolResults(result);
                
                logEvent('success', `Tool ${toolName} executed successfully`);
                
            } catch (error) {
                resultsDiv.innerHTML = `<div style="color: red;">Error: ${error.message}</div>`;
                logEvent('error', `Tool execution failed: ${error.message}`);
            }
        }
        
        async function executeMCPTool(agent, toolName, params) {
            logEvent('info', `Executing MCP tool ${toolName} with agent: ${agent.name} (ID: ${agent.id})`);
            return await executeMCPToolBackend(agent, toolName, params);
        }
        
        async function executeMCPToolBackend(agent, toolName, params) {
            const request = {
                tool: toolName,
                params: params,
                brief: params.brief || "Test execution from ADCP Testing Suite"
            };
            
            
            const headers = {
                'Content-Type': 'application/json',
                'Content-Type': 'application/json'
            };
            
            // Add ADCP testing headers
            const testingHeaders = collectTestingHeaders();
            Object.assign(headers, testingHeaders);
            
            // Call backend API which will use official MCP client
            logEvent('info', `🔄 Backend MCP Request: POST /api/sales/agents/${agent.id}/query`);
            logEvent('info', `📤 MCP Request Headers: ${JSON.stringify(headers, null, 2)}`);
            logEvent('info', `📤 MCP Request Body: ${JSON.stringify({
                brandStory: params.brief || "Test execution from ADCP Testing Suite",
                offering: null,
                agentConfig: agent
            }, null, 2)}`);
            
            const response = await fetch(`/api/sales/agents/${agent.id}/query`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    brandStory: params.brief || "Test execution from ADCP Testing Suite",
                    offering: null,
                    agentConfig: agent
                })
            });
            
            logEvent('info', `📥 MCP Response Status: ${response.status} ${response.statusText}`);
            
            const result = await response.json();
            logEvent('info', `📥 MCP Response Body: ${JSON.stringify(result, null, 2)}`);
            
            // Display debug logs from backend if available
            if (result.debug_logs && Array.isArray(result.debug_logs)) {
                displayDebugLogs(result.debug_logs, agent);
            } else if (result.debugLogs && Array.isArray(result.debugLogs)) {
                // Handle legacy property name
                displayDebugLogs(result.debugLogs, agent);
            } else {
            }
            
            // Display validation results if available
            if (result.validation) {
                displayValidationResult(result.validation, agent);
            }
            
            // Log response headers for debugging
            logResponseHeaders(response.headers);
            
            if (!response.ok || result.error) {
                logEvent('error', `❌ MCP API Error: ${result.error?.message || result.message || `HTTP ${response.status}`}`);
                throw new Error(result.error?.message || result.message || `HTTP ${response.status}`);
            }
            
            
            return result;
        }
        
        async function executeA2ATool(agent, toolName, params) {
            logEvent('info', `Executing A2A tool ${toolName} with agent: ${agent.name} (ID: ${agent.id})`);
            return await executeA2AToolBackend(agent, toolName, params);
        }
        
        async function executeA2AToolBackend(agent, toolName, params) {
            const request = {
                tool: toolName,
                params: params,
                brief: params.brief || "Test execution from ADCP Testing Suite"
            };
            
            
            const headers = {
                'Content-Type': 'application/json',
                'Content-Type': 'application/json'
            };
            
            // Add ADCP testing headers
            const testingHeaders = collectTestingHeaders();
            Object.assign(headers, testingHeaders);
            
            // Call backend API which will use official A2A client
            logEvent('info', `🔄 Backend A2A Request: POST /api/sales/agents/${agent.id}/query`);
            logEvent('info', `📤 A2A Request Headers: ${JSON.stringify(headers, null, 2)}`);
            logEvent('info', `📤 A2A Request Body: ${JSON.stringify({
                brandStory: params.brief || "Test execution from ADCP Testing Suite",
                offering: null,
                agentConfig: agent
            }, null, 2)}`);
            
            const response = await fetch(`/api/sales/agents/${agent.id}/query`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    brandStory: params.brief || "Test execution from ADCP Testing Suite",
                    offering: null,
                    agentConfig: agent
                })
            });
            
            logEvent('info', `📥 A2A Response Status: ${response.status} ${response.statusText}`);
            
            const result = await response.json();
            logEvent('info', `📥 A2A Response Body: ${JSON.stringify(result, null, 2)}`);
            
            // Display debug logs from backend if available
            if (result.debug_logs && Array.isArray(result.debug_logs)) {
                displayDebugLogs(result.debug_logs, agent);
            } else if (result.debugLogs && Array.isArray(result.debugLogs)) {
                // Handle legacy property name
                displayDebugLogs(result.debugLogs, agent);
            } else {
            }
            
            // Display validation results if available
            if (result.validation) {
                displayValidationResult(result.validation, agent);
            }
            
            // Log response headers for debugging
            logResponseHeaders(response.headers);
            
            if (!response.ok || result.error) {
                logEvent('error', `❌ A2A API Error: ${result.error?.message || result.message || `HTTP ${response.status}`}`);
                throw new Error(result.error?.message || result.message || `HTTP ${response.status}`);
            }
            
            
            return result;
        }
        
        function showToolResults(result) {
            const resultsDiv = document.getElementById('tool-results');
            const resultId = `result-${Date.now()}`;
            
            resultsDiv.innerHTML = `
                <div class="debug-panel">
                    <div class="debug-header" onclick="togglePanelById('${resultId}')">
                        <span>Tool Execution Result</span>
                        <button class="copy-btn" onclick="copyToClipboardById('${resultId}-content', event)">Copy</button>
                    </div>
                    <div class="debug-content expanded" id="${resultId}">
                        <div id="${resultId}-content" class="debug-code">
${JSON.stringify(result, null, 2)}
                        </div>
                    </div>
                </div>
            `;
        }

        // ============================================================================
        // Workflow Execution
        // ============================================================================
        
        async function startWorkflow() {
            const brief = document.getElementById('campaign-brief').value;
            const offering = document.getElementById('promoted-offering').value;
            const budget = document.getElementById('campaign-budget').value;
            
            if (!brief) {
                alert('Please enter a campaign brief');
                return;
            }
            
            currentWorkflow = {
                id: Date.now(),
                brief: brief,
                offering: offering,
                budget: budget,
                stage: 'discovery',
                status: 'running',
                results: {}
            };
            
            logEvent('success', 'Workflow started');
            setWorkflowStage('discovery');
            
            // Execute workflow stages
            await executeWorkflowStage('discovery');
        }
        
        async function executeWorkflowStage(stage) {
            const statusDiv = document.getElementById('workflow-status');
            statusDiv.innerHTML = `<div class="loading-spinner"></div> Executing ${stage}...`;
            
            // Simulate stage execution
            setTimeout(() => {
                // Move to next stage
                const stages = ['discovery', 'strategy', 'creative', 'execution', 'monitoring'];
                const currentIndex = stages.indexOf(stage);
                
                if (currentIndex < stages.length - 1) {
                    const nextStage = stages[currentIndex + 1];
                    
                    // Check if approval is needed
                    if (stage === 'strategy' || stage === 'creative') {
                        statusDiv.innerHTML = `Stage ${stage} complete. Awaiting approval...`;
                        addApprovalRequest(stage);
                        setWorkflowStage(stage);
                        document.querySelector(`[data-stage="${stage}"]`).classList.add('pending-approval');
                    } else {
                        setWorkflowStage(nextStage);
                        executeWorkflowStage(nextStage);
                    }
                } else {
                    statusDiv.innerHTML = 'Workflow complete!';
                    logEvent('success', 'Workflow completed successfully');
                }
            }, 2000);
        }
        
        function pauseWorkflow() {
            if (currentWorkflow) {
                currentWorkflow.status = 'paused';
                logEvent('warning', 'Workflow paused');
            }
        }
        
        function cancelWorkflow() {
            if (currentWorkflow) {
                currentWorkflow.status = 'cancelled';
                currentWorkflow = null;
                logEvent('error', 'Workflow cancelled');
                document.getElementById('workflow-status').innerHTML = 'Workflow cancelled';
            }
        }

        // ============================================================================
        // Approval Management
        // ============================================================================
        
        function addApprovalRequest(stage) {
            const request = {
                id: Date.now(),
                stage: stage,
                timestamp: new Date(),
                status: 'pending'
            };
            
            approvalQueue.push(request);
            updateApprovalUI();
        }
        
        function updateApprovalUI() {
            // Update approval stage cards
            const stages = ['strategy', 'creative', 'budget'];
            stages.forEach(stage => {
                const request = approvalQueue.find(r => r.stage === stage && r.status === 'pending');
                const card = document.querySelector(`.approval-stage-card:has(h4:contains("${stage}"))`);
                
                if (card && request) {
                    const indicator = card.querySelector('.approval-indicator');
                    const status = card.querySelector('.approval-status span:last-child');
                    const buttons = card.querySelectorAll('button');
                    
                    indicator.className = 'approval-indicator pending';
                    status.textContent = 'Pending Review';
                    buttons.forEach(btn => btn.disabled = false);
                }
            });
        }
        
        function approveStage(stage) {
            const request = approvalQueue.find(r => r.stage === stage && r.status === 'pending');
            if (request) {
                request.status = 'approved';
                logEvent('success', `${stage} approved`);
                
                // Continue workflow if applicable
                if (currentWorkflow && currentWorkflow.status === 'running') {
                    const stages = ['discovery', 'strategy', 'creative', 'execution', 'monitoring'];
                    const nextStage = stages[stages.indexOf(stage) + 1];
                    if (nextStage) {
                        setWorkflowStage(nextStage);
                        executeWorkflowStage(nextStage);
                    }
                }
                
                updateApprovalUI();
            }
        }
        
        function requestChanges(stage) {
            const feedback = prompt('Please provide feedback for changes:');
            if (feedback) {
                logEvent('warning', `Changes requested for ${stage}: ${feedback}`);
            }
        }
        
        function rejectStage(stage) {
            const reason = prompt('Please provide rejection reason:');
            if (reason) {
                const request = approvalQueue.find(r => r.stage === stage && r.status === 'pending');
                if (request) {
                    request.status = 'rejected';
                    logEvent('error', `${stage} rejected: ${reason}`);
                    updateApprovalUI();
                }
            }
        }
        
        function simulateApprovalRequest() {
            addApprovalRequest('strategy');
            logEvent('info', 'Simulated approval request created');
        }
        
        function reviewItem(itemId) {
            alert(`Reviewing item ${itemId}`);
        }

        // ============================================================================
        // Streaming Status Management
        // ============================================================================
        
        
        
        function logEvent(type, message) {
            const log = document.getElementById('event-log');
            if (!log) {
                return;
            }
            
            const entry = document.createElement('div');
            entry.className = `event-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `
                <span class="timestamp">${timestamp}</span>
                <span class="event-type">[${type.toUpperCase()}]</span>
                ${message}
            `;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        function clearEventLog() {
            const log = document.getElementById('event-log');
            if (!log) {
                return;
            }
            
            log.innerHTML = `
                <div class="event-entry">
                    <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    <span class="event-type">[SYSTEM]</span>
                    Event log cleared
                </div>
            `;
        }
        
        function simulateEvents() {
            const events = [
                { type: 'info', message: 'Task started: get_products' },
                { type: 'success', message: 'Products discovered: 47 items' },
                { type: 'warning', message: 'Approval required for strategy' },
                { type: 'info', message: 'Optimization available: Increase bid by 15%' },
                { type: 'error', message: 'Creative asset validation failed' },
                { type: 'success', message: 'Campaign launched successfully' }
            ];
            
            let index = 0;
            const interval = setInterval(() => {
                if (index < events.length) {
                    logEvent(events[index].type, events[index].message);
                    index++;
                } else {
                    clearInterval(interval);
                }
            }, 1000);
        }

        // ============================================================================
        // Compliance Testing
        // ============================================================================
        
        function selectTestCategory(category) {
            document.querySelectorAll('.test-category').forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }
        
        async function runComplianceTests() {
            const selected = document.querySelector('.test-category.selected');
            const category = selected ? selected.textContent.trim().toLowerCase() : 'all';
            
            const resultsDiv = document.getElementById('compliance-results');
            resultsDiv.innerHTML = '<div class="loading-spinner"></div> Running tests...';
            
            // Define test suites
            const tests = {
                mcp: [
                    { name: 'JSONRPC 2.0 Format', test: testMCPFormat },
                    { name: 'Tools Discovery', test: testMCPToolsDiscovery },
                    { name: 'Tool Invocation', test: testMCPToolInvocation },
                    { name: 'Error Handling', test: testMCPErrorHandling }
                ],
                a2a: [
                    { name: 'Agent Card Discovery', test: testA2AAgentCard },
                    { name: 'Message Format', test: testA2AMessageFormat },
                    { name: 'Task Creation', test: testA2ATaskCreation },
                    { name: 'Response Validation', test: testA2AResponse }
                ],
                adcp: [
                    { name: 'Campaign Brief Structure', test: testADCPBrief },
                    { name: 'Product Discovery', test: testADCPProducts },
                    { name: 'Media Buy Creation', test: testADCPMediaBuy },
                    { name: 'Approval Workflow', test: testADCPApproval }
                ]
            };
            
            let testsToRun = [];
            if (category === 'all' || category.includes('all')) {
                testsToRun = [...tests.mcp, ...tests.a2a, ...tests.adcp];
            } else if (category.includes('mcp')) {
                testsToRun = tests.mcp;
            } else if (category.includes('a2a')) {
                testsToRun = tests.a2a;
            } else if (category.includes('adcp')) {
                testsToRun = tests.adcp;
            }
            
            // Run tests
            const results = [];
            for (const test of testsToRun) {
                const result = await runSingleTest(test);
                results.push(result);
            }
            
            // Display results
            displayTestResults(results);
            calculateComplianceScore(results);
        }
        
        async function runSingleTest(test) {
            try {
                const passed = await test.test();
                return { name: test.name, status: passed ? 'pass' : 'fail' };
            } catch (error) {
                return { name: test.name, status: 'fail', error: error.message };
            }
        }
        
        // Sample test implementations
        async function testMCPFormat() {
            // Test JSONRPC 2.0 format compliance
            return true; // Simplified for demo
        }
        
        async function testMCPToolsDiscovery() {
            // Test tools/list endpoint
            return true;
        }
        
        async function testMCPToolInvocation() {
            // Test tools/call endpoint
            return true;
        }
        
        async function testMCPErrorHandling() {
            // Test error response format
            return true;
        }
        
        async function testA2AAgentCard() {
            // Test agent card discovery
            return true;
        }
        
        async function testA2AMessageFormat() {
            // Test message structure
            return true;
        }
        
        async function testA2ATaskCreation() {
            // Test task creation response
            return true;
        }
        
        async function testA2AResponse() {
            // Test response validation
            return true;
        }
        
        async function testADCPBrief() {
            // Test campaign brief structure
            return true;
        }
        
        async function testADCPProducts() {
            // Test product discovery
            return true;
        }
        
        async function testADCPMediaBuy() {
            // Test media buy creation
            return true;
        }
        
        async function testADCPApproval() {
            // Test approval workflow
            return true;
        }
        
        function displayTestResults(results) {
            const resultsDiv = document.getElementById('compliance-results');
            resultsDiv.innerHTML = results.map(result => `
                <div class="test-result ${result.status}">
                    <span class="test-name">${result.name}</span>
                    <span class="test-status ${result.status}">${result.status.toUpperCase()}</span>
                </div>
            `).join('');
        }
        
        function calculateComplianceScore(results) {
            const passed = results.filter(r => r.status === 'pass').length;
            const total = results.length;
            const score = Math.round((passed / total) * 100);
            
            document.getElementById('compliance-score').textContent = score;
            
            const summary = document.getElementById('compliance-summary');
            summary.innerHTML = `
                <div>Tests Passed: ${passed}/${total}</div>
                <div>Status: ${score >= 80 ? 'Compliant' : score >= 60 ? 'Partially Compliant' : 'Non-Compliant'}</div>
            `;
        }
        
        function exportTestResults() {
            const results = {
                timestamp: new Date().toISOString(),
                score: document.getElementById('compliance-score').textContent,
                results: testResults
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `compliance-results-${Date.now()}.json`;
            a.click();
        }

        // ============================================================================
        // ADCP Testing Headers Functions
        // ============================================================================
        
        
        function logResponseHeaders(responseHeaders) {
            // Log ADCP response headers
            const adcpHeaders = ['X-Dry-Run', 'X-Test-Session-ID', 'X-Mock-Time', 'X-Next-Event', 'X-Next-Event-Time', 'X-Simulated-Spend'];
            
            adcpHeaders.forEach(header => {
                const value = responseHeaders.get(header);
                if (value) {
                    logEvent('info', `Response Header ${header}: ${value}`);
                }
            });
        }
        
        function resetTestingHeaders() {
            document.getElementById('enable-dry-run').checked = true;
            document.getElementById('test-session-id').value = '';
            document.getElementById('mock-time').value = '';
            document.getElementById('auto-advance').checked = false;
            document.getElementById('jump-to-event').value = '';
            document.getElementById('advance-time').value = '';
            
            logEvent('info', 'Testing headers reset to defaults');
        }
        
        function generateTestSessionId() {
            const sessionId = `test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            document.getElementById('test-session-id').value = sessionId;
            logEvent('info', `Generated test session ID: ${sessionId}`);
        }

        // ============================================================================
        // Data Flow Chaining Functions
        // ============================================================================
        
        function getChainedValue(toolName, param) {
            if (!document.getElementById('enable-data-chaining').checked) {
                return null;
            }
            
            // Define chaining rules - which tool outputs map to which tool inputs
            const chainRules = {
                // get_products output -> create_media_buy input
                'create_media_buy': {
                    'products': 'get_products.result.products',
                    'targeting': 'get_products.result.targeting_suggestions',
                    'budget': 'get_products.result.recommended_budget'
                },
                // create_media_buy output -> manage_creative_assets input
                'manage_creative_assets': {
                    'media_buy_id': 'create_media_buy.result.media_buy_id'
                },
                // create_media_buy output -> add_creative_assets input (deprecated)
                'add_creative_assets': {
                    'media_buy_id': 'create_media_buy.result.media_buy_id'
                },
                // create_media_buy output -> get_media_buy_delivery input
                'get_media_buy_delivery': {
                    'media_buy_id': 'create_media_buy.result.media_buy_id'
                },
                // create_media_buy output -> update_media_buy input
                'update_media_buy': {
                    'media_buy_id': 'create_media_buy.result.media_buy_id'
                }
            };
            
            const rules = chainRules[toolName];
            if (!rules || !rules[param]) {
                return null;
            }
            
            const sourcePath = rules[param];
            const [sourceTool, ...pathParts] = sourcePath.split('.');
            
            if (dataChain[sourceTool]) {
                let value = dataChain[sourceTool];
                
                // Navigate through the path (e.g., result.products)
                for (const part of pathParts) {
                    if (value && typeof value === 'object' && part in value) {
                        value = value[part];
                    } else {
                        return null;
                    }
                }
                
                // Format the value appropriately
                if (Array.isArray(value) || (typeof value === 'object' && value !== null)) {
                    return JSON.stringify(value, null, 2);
                }
                
                return String(value);
            }
            
            return null;
        }
        
        function updateChainingStatus(currentTool) {
            // Show which tools have data available for chaining
            const availableData = Object.keys(dataChain);
            if (availableData.length > 0) {
                logEvent('info', `Available chain data: ${availableData.join(', ')}`);
            }
        }
        
        function clearChainedData() {
            dataChain = {};
            logEvent('info', 'Data flow chain cleared');
            updateToolParams(); // Refresh the current tool params
        }
        
        function storeResultInChain(toolName, result) {
            if (document.getElementById('enable-data-chaining').checked) {
                dataChain[toolName] = result;
                logEvent('success', `Stored result from ${toolName} in data chain`);
            }
        }

        // ============================================================================
        // Helper Functions
        // ============================================================================
        
        function togglePanelById(panelId) {
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.classList.toggle('expanded');
            }
        }
        
        function copyToClipboardById(elementId, event) {
            event.stopPropagation();
            const element = document.getElementById(elementId);
            const text = element.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1000);
            });
        }
        
        
        // Switch between manual and JSON input methods
        function switchInputMethod(method) {
            const manualTab = document.getElementById('manual-tab');
            const jsonTab = document.getElementById('json-tab');
            const manualEntry = document.getElementById('manual-entry');
            const jsonEntry = document.getElementById('json-entry');
            
            if (method === 'manual') {
                // Activate manual tab
                manualTab.style.background = '#1a4d3a';
                jsonTab.style.background = '#6c757d';
                manualEntry.style.display = 'block';
                jsonEntry.style.display = 'none';
            } else {
                // Activate JSON tab
                manualTab.style.background = '#6c757d';
                jsonTab.style.background = '#1a4d3a';
                manualEntry.style.display = 'none';
                jsonEntry.style.display = 'block';
            }
        }
        
        // Add a new agent
        function addAgent() {
            // Check which input method is currently active
            const manualEntry = document.getElementById('manual-entry');
            const jsonEntry = document.getElementById('json-entry');
            
            let agent;
            
            if (manualEntry.style.display !== 'none') {
                // Manual entry mode
                agent = createAgentFromManualInput();
            } else {
                // JSON entry mode
                agent = createAgentFromJsonInput();
            }
            
            if (!agent) {
                return; // Error already shown to user
            }
            
            agents.push(agent);
            updateAgentSelector();
            saveCustomAgentsToStorage();
            
            // Clear form and hide it
            clearAgentForm();
            toggleAddAgent();
            
            // Don't auto-select agent - user should explicitly choose
            // document.getElementById('agent-selector').value = agent.id;
            logEvent('success', `Agent added: ${agent.name}`);
        }
        
        // Create agent from manual form input
        function createAgentFromManualInput() {
            const url = document.getElementById('agent-url').value.trim();
            const protocol = document.getElementById('protocol').value;
            const authToken = document.getElementById('auth-token').value.trim();
            const name = document.getElementById('agent-name').value.trim() || 'Unnamed Agent';
            
            if (!url) {
                alert('Please enter an agent URL');
                return null;
            }
            
            try {
                new URL(url); // Validate URL
            } catch (e) {
                alert('Please enter a valid URL');
                return null;
            }
            
            return {
                id: `custom-${Date.now()}`,
                name: name,
                agent_uri: url,
                protocol: protocol,
                auth_token_env: authToken,
                requiresAuth: !!authToken
            };
        }
        
        // Create agent from JSON input
        function createAgentFromJsonInput() {
            const jsonText = document.getElementById('agent-json').value.trim();
            
            if (!jsonText) {
                alert('Please enter agent configuration JSON');
                return null;
            }
            
            let config;
            try {
                config = JSON.parse(jsonText);
            } catch (e) {
                alert('Invalid JSON format. Please check your syntax.');
                return null;
            }
            
            // Validate required fields
            if (!config.agent_uri && !config.url) {
                alert('JSON must include either "agent_uri" or "url" field');
                return null;
            }
            
            if (!config.protocol) {
                alert('JSON must include "protocol" field (either "mcp" or "a2a")');
                return null;
            }
            
            if (!['mcp', 'a2a'].includes(config.protocol)) {
                alert('Protocol must be either "mcp" or "a2a"');
                return null;
            }
            
            // Extract URL (support both agent_uri and url fields)
            const url = config.agent_uri || config.url;
            
            try {
                new URL(url); // Validate URL
            } catch (e) {
                alert('Please provide a valid URL in the JSON');
                return null;
            }
            
            return {
                id: `custom-${Date.now()}`,
                name: config.name || 'Imported Agent',
                agent_uri: url,
                protocol: config.protocol,
                auth_token_env: config.auth_token_env || config.auth_token || '',
                requiresAuth: !!(config.auth_token_env || config.auth_token)
            };
        }
        
        // Clear all form inputs
        function clearAgentForm() {
            // Manual form fields
            document.getElementById('agent-url').value = '';
            document.getElementById('auth-token').value = '';
            document.getElementById('agent-name').value = '';
            document.getElementById('protocol').value = 'mcp';
            
            // JSON form field
            document.getElementById('agent-json').value = '';
            
            // Reset to manual tab
            switchInputMethod('manual');
        }
        
        // Local Storage Functions
        function saveCustomAgentsToStorage() {
            try {
                // Only save custom agents (those with IDs starting with 'custom-')
                const customAgents = agents.filter(agent => agent.id.startsWith('custom-'));
                localStorage.setItem(CUSTOM_AGENTS_STORAGE_KEY, JSON.stringify(customAgents));
                logEvent('info', `Saved ${customAgents.length} custom agents to local storage`);
            } catch (error) {
                logEvent('error', `Error saving custom agents to storage: ${error.message}`);
            }
        }
        
        function loadCustomAgentsFromStorage() {
            try {
                const stored = localStorage.getItem(CUSTOM_AGENTS_STORAGE_KEY);
                if (stored) {
                    const customAgents = JSON.parse(stored);
                    if (Array.isArray(customAgents)) {
                        // Merge custom agents with API agents
                        const customIds = customAgents.map(a => a.id);
                        agents = agents.filter(agent => !customIds.includes(agent.id));
                        agents = [...agents, ...customAgents];
                        updateAgentSelector();
                        logEvent('info', `Loaded ${customAgents.length} custom agents from local storage`);
                    }
                }
            } catch (error) {
                logEvent('error', `Error loading custom agents from storage: ${error.message}`);
            }
        }
        
        function clearCustomAgentsFromStorage() {
            if (confirm('Are you sure you want to clear all saved custom agents? This cannot be undone.')) {
                try {
                    localStorage.removeItem(CUSTOM_AGENTS_STORAGE_KEY);
                    // Remove custom agents from memory
                    agents = agents.filter(agent => !agent.id.startsWith('custom-'));
                    updateAgentSelector();
                    logEvent('warning', 'Custom agents have been cleared from storage');
                } catch (error) {
                    logEvent('error', `Error clearing custom agents from storage: ${error.message}`);
                }
            }
        }
        
        function updateAgentSelector() {
            const selector = document.getElementById('agent-selector');
            selector.innerHTML = '<option value="">Select an agent...</option>';
            
            logEvent('info', `Updating agent selector with ${agents.length} agents`);
            
            agents.forEach((agent, index) => {
                logEvent('info', `Agent: ${agent.name} (ID: ${agent.id}), has auth: ${!!agent.auth_token}`);
                const option = document.createElement('option');
                option.value = agent.id;
                option.textContent = `${agent.name} (${agent.protocol.toUpperCase()})`;
                selector.appendChild(option);
            });
            
            // Auto-select the first agent for convenience
            if (agents.length > 0) {
                selector.value = agents[0].id;
                logEvent('info', `Auto-selected agent: ${agents[0].name}`);
                // Trigger onAgentSelected to enable the Load Agent Data button
                onAgentSelected();
            }
        }

        // ============================================================================
        // Agent Management & Debugging
        // ============================================================================
        
        function viewAllAgents() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); z-index: 1000; display: flex;
                align-items: center; justify-content: center;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white; padding: 20px; border-radius: 8px;
                max-width: 800px; max-height: 80%; overflow-y: auto;
                border: 1px solid #ccc;
            `;

            let html = '<h3>🤖 All Agents</h3>';

            if (agents.length === 0) {
                html += '<p>No agents found.</p>';
            } else {
                html += '<table border="1" cellpadding="8" cellspacing="0" style="width: 100%; border-collapse: collapse;">';
                html += '<tr><th>Name</th><th>ID</th><th>Protocol</th><th>Auth Token</th><th>Actions</th></tr>';

                agents.forEach(agent => {
                    const authToken = agent.auth_token || agent.auth_token_env;
                    const hasToken = !!authToken;
                    const tokenDisplay = hasToken ?
                        `✅ Yes (${authToken.length} chars)` :
                        '❌ No';

                    // Escape agent ID for safe use in onclick attribute
                    const escapedId = agent.id.replace(/'/g, "\\'");

                    html += `<tr>
                        <td>${agent.name}</td>
                        <td><code>${agent.id}</code></td>
                        <td>${agent.protocol.toUpperCase()}</td>
                        <td>${tokenDisplay}</td>
                        <td>
                            <button onclick="editAgent('${escapedId}')" style="background: #007bff; color: white; border: none; padding: 4px 8px; margin-right: 5px; cursor: pointer;">Edit</button>
                            <button onclick="deleteAgent('${escapedId}')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; cursor: pointer;">Delete</button>
                        </td>
                    </tr>`;
                });

                html += '</table>';
            }

            html += '<br><button onclick="this.closest(\'.modal\').remove()" style="background: #28a745; color: white; border: none; padding: 8px 16px; cursor: pointer;">Close</button>';

            content.innerHTML = html;
            modal.className = 'modal';
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function deleteAgent(agentId) {
            if (confirm('Are you sure you want to delete this agent?')) {
                agents = agents.filter(agent => agent.id !== agentId);
                saveCustomAgentsToStorage();
                updateAgentSelector();
                logEvent('success', `Deleted agent: ${agentId}`);
                
                // Close any open modals
                document.querySelectorAll('.modal').forEach(modal => modal.remove());
                
                // Refresh the view if still open
                if (document.querySelector('.modal')) {
                    viewAllAgents();
                }
            }
        }
        
        function editAgent(agentId) {
            const agent = agents.find(a => a.id === agentId);
            if (!agent) return;
            
            // Close the view modal
            document.querySelectorAll('.modal').forEach(modal => modal.remove());
            
            // Pre-fill the add agent form
            document.getElementById('agent-name').value = agent.name;
            document.getElementById('agent-uri').value = agent.agent_uri;
            document.getElementById('agent-protocol').value = agent.protocol;
            document.getElementById('auth-token').value = agent.auth_token || agent.auth_token_env || '';
            
            // Show the form
            toggleAddAgent();
            
            // Remove the old agent so we don't have duplicates
            agents = agents.filter(a => a.id !== agentId);
            
            logEvent('info', `Editing agent: ${agent.name}`);
        }
        

        // ============================================================================
        // Creative Management Functions
        // ============================================================================
        
        function showCreateModal() {
            // Load creative formats first
            if (creativeFormats.length === 0) {
                logEvent('warning', 'No creative formats loaded. Loading formats first...');
                refreshCreativeFormats().then(() => {
                    populateFormatSelector();
                    document.getElementById('creative-create-modal').style.display = 'block';
                });
            } else {
                populateFormatSelector();
                document.getElementById('creative-create-modal').style.display = 'block';
            }
        }

        function closeCreateModal() {
            document.getElementById('creative-create-modal').style.display = 'none';
            resetCreateForm();
        }

        function showUpdateModal() {
            document.getElementById('creative-update-modal').style.display = 'block';
        }

        function closeUpdateModal() {
            document.getElementById('creative-update-modal').style.display = 'none';
        }

        function updateCreateUI() {
            const mode = document.getElementById('create-mode').value;
            document.getElementById('single-create').style.display = mode === 'single' ? 'block' : 'none';
            document.getElementById('json-create').style.display = mode === 'json' ? 'block' : 'none';
            document.getElementById('batch-create').style.display = mode === 'batch' ? 'block' : 'none';
        }

        function populateFormatSelector() {
            const selector = document.getElementById('creative-format-selector');
            selector.innerHTML = '<option value="">-- Choose a format --</option>';

            if (creativeFormats.length === 0) {
                selector.innerHTML += '<option value="" disabled>No formats available - refresh formats first</option>';
                return;
            }

            creativeFormats.forEach(format => {
                const option = document.createElement('option');
                option.value = format.format_id;

                // Extract dimensions from various possible locations
                let width = '?', height = '?';

                if (format.dimensions && format.dimensions.width && format.dimensions.height) {
                    width = format.dimensions.width;
                    height = format.dimensions.height;
                } else if (format.assets_required && Array.isArray(format.assets_required)) {
                    // Try to extract from assets_required array
                    const dimensionAsset = format.assets_required.find(a => a.width && a.height);
                    if (dimensionAsset) {
                        width = dimensionAsset.width;
                        height = dimensionAsset.height;
                    }
                } else if (format.format_id && format.format_id.includes('x')) {
                    // Try to parse from format_id like "300x250"
                    const match = format.format_id.match(/(\d+)x(\d+)/);
                    if (match) {
                        width = match[1];
                        height = match[2];
                    }
                }

                option.textContent = `${format.name || format.format_id} (${width}×${height})`;
                option.dataset.format = JSON.stringify(format);
                selector.appendChild(option);
            });
        }

        function onCreativeFormatSelected() {
            const selector = document.getElementById('creative-format-selector');
            const selectedOption = selector.options[selector.selectedIndex];

            if (!selectedOption || !selectedOption.dataset.format) {
                document.getElementById('format-requirements').style.display = 'none';
                document.getElementById('creative-fields').style.display = 'none';
                return;
            }

            const format = JSON.parse(selectedOption.dataset.format);

            // Extract dimensions (same logic as populateFormatSelector)
            let width = '?', height = '?';
            if (format.dimensions && format.dimensions.width && format.dimensions.height) {
                width = format.dimensions.width;
                height = format.dimensions.height;
            } else if (format.assets_required && Array.isArray(format.assets_required)) {
                const dimensionAsset = format.assets_required.find(a => a.width && a.height);
                if (dimensionAsset) {
                    width = dimensionAsset.width;
                    height = dimensionAsset.height;
                }
            } else if (format.format_id && format.format_id.includes('x')) {
                const match = format.format_id.match(/(\d+)x(\d+)/);
                if (match) {
                    width = match[1];
                    height = match[2];
                }
            }

            // Show format requirements
            const reqDetails = document.getElementById('format-req-details');
            let reqHTML = `<strong>${format.name || format.format_id}</strong><br>`;
            reqHTML += `Dimensions: ${width} × ${height}px`;

            if (format.aspect_ratio) {
                reqHTML += ` (${format.aspect_ratio})`;
            }

            if (format.file_types && format.file_types.length > 0) {
                reqHTML += `<br>Supported types: ${format.file_types.join(', ')}`;
            }

            if (format.max_file_size) {
                const sizeMB = (format.max_file_size / (1024 * 1024)).toFixed(1);
                reqHTML += `<br>Max file size: ${sizeMB} MB`;
            }

            if (format.duration_range) {
                reqHTML += `<br>Duration: ${format.duration_range.min}-${format.duration_range.max} seconds`;
            }

            reqDetails.innerHTML = reqHTML;
            document.getElementById('format-requirements').style.display = 'block';
            document.getElementById('creative-fields').style.display = 'block';

            // Show/hide type-specific fields
            const formatType = format.type || (format.format_id?.includes('video') ? 'video' : format.format_id?.includes('native') ? 'native' : 'display');
            document.getElementById('video-specific-fields').style.display = formatType === 'video' ? 'block' : 'none';
            document.getElementById('native-specific-fields').style.display = formatType === 'native' ? 'block' : 'none';
        }

        function toggleAssetSource() {
            const source = document.querySelector('input[name="asset-source"]:checked').value;
            document.getElementById('hosted-asset-fields').style.display = source === 'hosted' ? 'block' : 'none';
            document.getElementById('snippet-asset-fields').style.display = source === 'snippet' ? 'block' : 'none';
        }

        function resetCreateForm() {
            document.getElementById('creative-format-selector').value = '';
            document.getElementById('creative-name').value = '';
            document.getElementById('creative-url').value = '';
            document.getElementById('creative-snippet').value = '';
            document.getElementById('impression-trackers').value = '';
            document.getElementById('click-trackers').value = '';
            document.getElementById('creative-tags').value = '';
            document.getElementById('landing-url').value = '';
            document.getElementById('video-duration').value = '';
            document.getElementById('vast-url').value = '';
            document.getElementById('native-title').value = '';
            document.getElementById('native-description').value = '';
            document.getElementById('native-cta').value = '';
            document.getElementById('single-creative-json').value = '';
            document.getElementById('format-requirements').style.display = 'none';
            document.getElementById('creative-fields').style.display = 'none';
        }
        
        function updateUpdateUI() {
            const mode = document.getElementById('update-mode').value;
            document.getElementById('single-update').style.display = mode === 'single' ? 'block' : 'none';
            document.getElementById('batch-update').style.display = mode === 'batch' ? 'block' : 'none';
        }
        
        function toggleMediaBuyInput() {
            const checkbox = document.getElementById('assign-to-media-buy');
            const input = document.getElementById('target-media-buy-id');
            input.style.display = checkbox.checked ? 'inline-block' : 'none';
            if (!checkbox.checked) {
                input.value = '';
            }
        }

        async function executeCreativeCreate() {
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                alert('Please select an agent first');
                return;
            }

            // Get the create button and add loading state
            const createButton = event.target;
            const originalText = createButton.textContent;
            createButton.disabled = true;
            createButton.textContent = 'Creating...';

            try {
                const mode = document.getElementById('create-mode').value;
                let assets = [];

                if (mode === 'json') {
                    // Parse single creative JSON and pass through as-is
                    try {
                        const jsonStr = document.getElementById('single-creative-json').value.trim();
                        if (!jsonStr) {
                            alert('Please paste creative JSON');
                            return;
                        }

                        const creative = JSON.parse(jsonStr);

                        // Send the JSON as-is - no translation
                        assets.push(creative);

                    } catch (e) {
                        alert('Invalid JSON: ' + e.message);
                        return;
                    }
                } else if (mode === 'single') {
                    // Validate required fields
                    const formatSelector = document.getElementById('creative-format-selector');
                    if (!formatSelector.value) {
                        alert('Please select a creative format');
                        return;
                    }

                    const creativeName = document.getElementById('creative-name').value.trim();
                    if (!creativeName) {
                        alert('Please enter a creative name');
                        return;
                    }

                    // Get selected format
                    const selectedOption = formatSelector.options[formatSelector.selectedIndex];
                    const format = JSON.parse(selectedOption.dataset.format);

                    // Extract dimensions (same logic as other functions)
                    let width, height;
                    if (format.dimensions && format.dimensions.width && format.dimensions.height) {
                        width = format.dimensions.width;
                        height = format.dimensions.height;
                    } else if (format.assets_required && Array.isArray(format.assets_required)) {
                        const dimensionAsset = format.assets_required.find(a => a.width && a.height);
                        if (dimensionAsset) {
                            width = dimensionAsset.width;
                            height = dimensionAsset.height;
                        }
                    } else if (format.format_id && format.format_id.includes('x')) {
                        const match = format.format_id.match(/(\d+)x(\d+)/);
                        if (match) {
                            width = parseInt(match[1]);
                            height = parseInt(match[2]);
                        }
                    }

                    // Determine asset source
                    const assetSource = document.querySelector('input[name="asset-source"]:checked').value;

                    const asset = {
                        name: creativeName,
                        format: format.format_id,
                        status: 'active'
                    };

                    // Add dimensions if we found them
                    if (width && height) {
                        asset.dimensions = { width, height };
                    }

                    // Asset content
                    if (assetSource === 'hosted') {
                        const mediaUrl = document.getElementById('creative-url').value.trim();
                        if (!mediaUrl) {
                            alert('Please enter a media URL');
                            return;
                        }
                        asset.media_url = mediaUrl;
                    } else {
                        const snippet = document.getElementById('creative-snippet').value.trim();
                        if (!snippet) {
                            alert('Please enter a creative snippet');
                            return;
                        }
                        asset.snippet = snippet;
                        asset.snippet_type = document.getElementById('snippet-type').value;
                    }

                    // Trackers
                    const impressionTrackers = document.getElementById('impression-trackers').value
                        .split('\n')
                        .map(t => t.trim())
                        .filter(t => t);
                    if (impressionTrackers.length > 0) {
                        asset.impression_trackers = impressionTrackers;
                    }

                    const clickTrackers = document.getElementById('click-trackers').value
                        .split('\n')
                        .map(t => t.trim())
                        .filter(t => t);
                    if (clickTrackers.length > 0) {
                        asset.click_trackers = clickTrackers;
                    }

                    // Landing URL
                    const landingUrl = document.getElementById('landing-url').value.trim();
                    if (landingUrl) {
                        asset.landing_url = landingUrl;
                    }

                    // Video-specific fields
                    const formatType = format.type || (format.format_id?.includes('video') ? 'video' : format.format_id?.includes('native') ? 'native' : 'display');
                    if (formatType === 'video') {
                        const duration = document.getElementById('video-duration').value;
                        if (duration) {
                            asset.duration = parseInt(duration);
                        }
                        const vastUrl = document.getElementById('vast-url').value.trim();
                        if (vastUrl) {
                            asset.vast_url = vastUrl;
                        }
                    }

                    // Native-specific fields
                    if (formatType === 'native') {
                        const title = document.getElementById('native-title').value.trim();
                        const description = document.getElementById('native-description').value.trim();
                        const cta = document.getElementById('native-cta').value.trim();

                        asset.native_elements = {};
                        if (title) asset.native_elements.title = title;
                        if (description) asset.native_elements.description = description;
                        if (cta) asset.native_elements.cta = cta;
                    }

                    // Tags
                    const tags = document.getElementById('creative-tags').value
                        .split(',')
                        .map(t => t.trim())
                        .filter(t => t);
                    if (tags.length > 0) {
                        asset.tags = tags;
                    }

                    assets.push(asset);
                } else {
                    // Parse batch JSON
                    try {
                        assets = JSON.parse(document.getElementById('batch-creatives-json').value);
                    } catch (e) {
                        alert('Invalid JSON for batch upload: ' + e.message);
                        return;
                    }
                }

                const assignToMediaBuy = document.getElementById('assign-to-media-buy')?.checked;
                const mediaBuyId = assignToMediaBuy ? document.getElementById('target-media-buy-id')?.value : null;

                // Use sync_creatives, not manage_creative_assets
                const params = {
                    creatives: assets
                };

                // Add assignments if media buy is specified
                if (mediaBuyId) {
                    params.assignments = {};
                    assets.forEach(asset => {
                        const creativeId = asset.id || asset.creative_id || asset.creativeId;
                        if (creativeId) {
                            params.assignments[creativeId] = [mediaBuyId];
                        }
                    });
                }

                logEvent('info', `➕ Creating ${assets.length} creative(s)...`);

                const result = await callADCPTool(selectedAgent, 'sync_creatives', params);

                if (result && result.success) {
                    logEvent('success', `✅ Successfully created ${assets.length} creative(s)`);
                    displayCreativeResults(result.data || result);
                    closeCreateModal();
                } else {
                    logEvent('error', `Failed to create creatives: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                logEvent('error', `Error creating creatives: ${error.message}`);
            } finally {
                // Always restore button state
                createButton.disabled = false;
                createButton.textContent = originalText;
            }
        }
        
        async function listCreatives() {
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                alert('Please select an agent first');
                return;
            }
            
            logEvent('info', '📋 Listing creatives...');
            
            try {
                const result = await callADCPTool(selectedAgent, 'list_creatives', {
                    include_assignments: true,
                    include_performance: true
                });
                
                if (result) {
                    const creatives = result.creatives || result.data?.creatives || [];
                    logEvent('success', `✅ Found ${creatives.length} creative(s)`);
                    displayCreativeResults(result);
                } else {
                    logEvent('error', 'Failed to list creatives');
                }
            } catch (error) {
                logEvent('error', `Error listing creatives: ${error.message}`);
            }
        }
        
        async function executeCreativeUpdate() {
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                alert('Please select an agent first');
                return;
            }
            
            // Get creatives to update from the modal
            const mode = document.getElementById('update-mode')?.value || 'single';
            let updates = [];
            
            if (mode === 'single') {
                const creativeId = document.getElementById('update-creative-id')?.value;
                if (!creativeId) {
                    alert('Please enter a Creative ID to update');
                    return;
                }
                updates.push({
                    id: creativeId,
                    name: document.getElementById('update-creative-name')?.value,
                    status: document.getElementById('update-creative-status')?.value || 'active',
                    tags: document.getElementById('update-creative-tags')?.value?.split(',').map(t => t.trim()).filter(t => t) || []
                });
            } else {
                try {
                    updates = JSON.parse(document.getElementById('batch-updates-json')?.value || '[]');
                } catch (e) {
                    alert('Invalid JSON format for batch updates');
                    return;
                }
            }
            
            logEvent('info', `✏️ Updating ${updates.length} creative(s)...`);
            
            try {
                const result = await callADCPTool(selectedAgent, 'sync_creatives', {
                    creatives: updates,
                    dry_run: false,
                    validation_mode: 'strict'
                });
                
                if (result) {
                    logEvent('success', `✅ Updated ${updates.length} creative(s)`);
                    displayCreativeResults(result);
                    closeUpdateModal();
                } else {
                    logEvent('error', 'Failed to update creatives');
                }
            } catch (error) {
                logEvent('error', `Error updating creatives: ${error.message}`);
            }
        }
        
        function displayCreativeResults(result) {
            const contentDiv = document.getElementById('creative-management-content');
            
            // Extract creatives from various possible response structures
            const creatives = result.creatives || 
                             result.data?.creatives || 
                             result.uploaded_creatives ||
                             result.synced_creatives ||
                             [];
            
            if (creatives.length === 0) {
                contentDiv.innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <p style="color: #666;">No creatives found</p>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div style="max-height: 400px; overflow-y: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid #ddd;">
                                <th style="padding: 10px; text-align: left;">ID</th>
                                <th style="padding: 10px; text-align: left;">Name</th>
                                <th style="padding: 10px; text-align: left;">Type</th>
                                <th style="padding: 10px; text-align: left;">Format</th>
                                <th style="padding: 10px; text-align: left;">Status</th>
                                <th style="padding: 10px; text-align: left;">Tags</th>
                                <th style="padding: 10px; text-align: left;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            creatives.forEach(creative => {
                const tags = (creative.tags || []).join(', ');
                const status = creative.status || 'unknown';
                const statusColor = status === 'active' ? 'green' : 
                                   status === 'paused' ? 'orange' : 
                                   status === 'archived' ? 'gray' : 'black';
                
                html += `
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-family: monospace; font-size: 12px;">
                            ${creative.id || creative.creative_id || 'N/A'}
                        </td>
                        <td style="padding: 10px;">${creative.name || 'Unnamed'}</td>
                        <td style="padding: 10px;">${creative.type || 'unknown'}</td>
                        <td style="padding: 10px;">${creative.format || 'N/A'}</td>
                        <td style="padding: 10px;">
                            <span style="color: ${statusColor}; font-weight: bold;">
                                ${status}
                            </span>
                        </td>
                        <td style="padding: 10px; font-size: 12px;">${tags || 'None'}</td>
                        <td style="padding: 10px;">
                            <button class="btn btn-small" onclick="assignCreativeToMediaBuy('${creative.id || creative.creative_id}')">
                                Assign
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            contentDiv.innerHTML = html;
        }
        
        function assignCreativeToMediaBuy(creativeId) {
            const mediaBuyId = prompt('Enter Media Buy ID to assign this creative to:');
            if (!mediaBuyId) return;
            
            const selectedAgent = agents.find(a => a.id === document.getElementById('agent-selector').value);
            if (!selectedAgent) {
                alert('Please select an agent first');
                return;
            }
            
            logEvent('info', `🔗 Assigning creative ${creativeId} to media buy ${mediaBuyId}...`);
            
            // Use sync_creatives to update assignments
            callADCPTool(selectedAgent, 'sync_creatives', {
                assignments: {
                    [creativeId]: [mediaBuyId]
                }
            }).then(result => {
                if (result && result.success) {
                    logEvent('success', `✅ Creative assigned successfully`);
                } else {
                    logEvent('error', `Failed to assign creative: ${result?.error || 'Unknown error'}`);
                }
            }).catch(error => {
                logEvent('error', `Error assigning creative: ${error.message}`);
            });
        }
        
        // Show/hide media buy ID field based on checkbox
        document.addEventListener('DOMContentLoaded', function() {
            const assignCheckbox = document.getElementById('assign-to-media-buy');
            const mediaBuyInput = document.getElementById('target-media-buy-id');
            
            if (assignCheckbox && mediaBuyInput) {
                assignCheckbox.addEventListener('change', function() {
                    mediaBuyInput.style.display = this.checked ? 'inline-block' : 'none';
                });
            }
        });
        
        // ============================================================================
        // Initialization
        // ============================================================================
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Agents are loaded dynamically from API - no hardcoded defaults
            // This prevents issues with mismatched agent IDs
            
            // Initialize task management
            initTaskManagement();
            
            // Initialize debug panel button position since it starts open
            const toggleBtn = document.querySelector('.toggle-debug-btn');
            if (debugPanelOpen && toggleBtn) {
                toggleBtn.classList.add('panel-open');
            }
            
            // Load custom agents from localStorage
            loadCustomAgentsFromStorage();
            
            // Save custom agents when the page is about to unload
            window.addEventListener('beforeunload', () => {
                saveCustomAgentsToStorage();
            });
            
            // Auto-generate session ID on page load
            generateNewTestSession();
            
            logEvent('info', 'ADCP Media Buy Testing Suite initialized');

            // Start webhook event polling
            startWebhookPolling();

            // Initialize debug panel with welcome message
            const debugContent = document.getElementById('debug-content');
            if (debugContent) {
                // The "Waiting for agent communication..." message is already set in HTML
            }
        });
    </script>
</body>
</html>