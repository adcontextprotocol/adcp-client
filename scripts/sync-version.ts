#!/usr/bin/env tsx

import { readFileSync, writeFileSync, existsSync } from 'fs';
import path from 'path';

// Get cached AdCP version
function getCachedAdCPVersion(): string {
  try {
    const indexPath = path.join(__dirname, '../schemas/cache/latest/index.json');
    if (!existsSync(indexPath)) {
      throw new Error('Schema index not found in cache. Please run "npm run sync-schemas" first.');
    }
    const index = JSON.parse(readFileSync(indexPath, 'utf8'));
    return index.adcp_version || '1.0.0';
  } catch (error) {
    console.error(`❌ Failed to get cached AdCP version:`, error.message);
    process.exit(1);
  }
}

// Get current package.json version
function getCurrentPackageVersion(): { version: string; adcpVersion?: string } {
  try {
    const packagePath = path.join(__dirname, '../package.json');
    const packageJson = JSON.parse(readFileSync(packagePath, 'utf8'));
    return {
      version: packageJson.version,
      adcpVersion: packageJson.adcp_version
    };
  } catch (error) {
    console.error(`❌ Failed to read package.json:`, error.message);
    process.exit(1);
  }
}

// Generate version.ts file with library and AdCP versions
function generateVersionFile(libraryVersion: string, adcpVersion: string): void {
  const versionFilePath = path.join(__dirname, '../src/lib/version.ts');
  const versionContent = `// Generated version information
// This file is auto-generated by sync-version.ts

/**
 * AdCP client library version
 */
export const LIBRARY_VERSION = '${libraryVersion}';

/**
 * AdCP specification version this library is compatible with
 */
export const ADCP_VERSION = '${adcpVersion}';

/**
 * Full version information
 */
export const VERSION_INFO = {
  library: '${libraryVersion}',
  adcp: '${adcpVersion}',
  compatible: true,
  generatedAt: '${new Date().toISOString()}'
} as const;

/**
 * Check if this library version is compatible with a given AdCP version
 */
export function isCompatibleWith(adcpVersion: string): boolean {
  // For now, we use exact version matching
  // Future versions might implement semantic version compatibility
  return adcpVersion === ADCP_VERSION;
}
`;

  writeFileSync(versionFilePath, versionContent);
  console.log(`✅ Generated version file: ${versionFilePath}`);
}

// Update package.json with AdCP version
function updatePackageJsonVersion(adcpVersion: string, autoUpdate: boolean = false): void {
  const packagePath = path.join(__dirname, '../package.json');
  const packageJson = JSON.parse(readFileSync(packagePath, 'utf8'));
  
  const currentLibraryVersion = packageJson.version;
  const currentAdcpVersion = packageJson.adcp_version;
  
  // Check if AdCP version has changed
  if (currentAdcpVersion === adcpVersion) {
    console.log(`✅ Package already aligned with AdCP v${adcpVersion}`);
    generateVersionFile(currentLibraryVersion, adcpVersion);
    return;
  }
  
  // Update adcp_version field
  packageJson.adcp_version = adcpVersion;
  
  if (autoUpdate) {
    // Auto-increment library version when AdCP version changes
    const [major, minor, patch] = currentLibraryVersion.split('.').map(Number);
    
    // Determine version bump strategy based on AdCP version change
    const [currentMajor, currentMinor] = (currentAdcpVersion || '0.0.0').split('.').map(Number);
    const [newMajor, newMinor] = adcpVersion.split('.').map(Number);
    
    let newLibraryVersion: string;
    
    if (newMajor > currentMajor) {
      // Major AdCP version change -> bump major library version
      newLibraryVersion = `${major + 1}.0.0`;
    } else if (newMinor > currentMinor) {
      // Minor AdCP version change -> bump minor library version  
      newLibraryVersion = `${major}.${minor + 1}.0`;
    } else {
      // Patch AdCP version change -> bump patch library version
      newLibraryVersion = `${major}.${minor}.${patch + 1}`;
    }
    
    packageJson.version = newLibraryVersion;
    console.log(`📈 Auto-updating library version: ${currentLibraryVersion} -> ${newLibraryVersion}`);
  }
  
  // Write updated package.json
  writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
  console.log(`✅ Updated package.json:`);
  console.log(`   📦 Library version: ${packageJson.version}`);
  console.log(`   🏷️  AdCP version: ${adcpVersion}`);
  
  // Generate version file
  generateVersionFile(packageJson.version, adcpVersion);
}

// Main sync function
async function syncVersion(): Promise<void> {
  console.log('🔄 Syncing version with AdCP specification...');
  
  // Get current state
  const adcpVersion = getCachedAdCPVersion();
  const { version: currentLibraryVersion, adcpVersion: currentAdcpVersion } = getCurrentPackageVersion();
  
  console.log(`📋 Current state:`);
  console.log(`   📦 Library version: ${currentLibraryVersion}`);
  console.log(`   🏷️  Current AdCP version: ${currentAdcpVersion || 'not set'}`);
  console.log(`   🎯 Target AdCP version: ${adcpVersion}`);
  
  // Check command line arguments
  const args = process.argv.slice(2);
  const autoUpdate = args.includes('--auto-update') || args.includes('-u');
  const forceUpdate = args.includes('--force') || args.includes('-f');
  
  if (currentAdcpVersion === adcpVersion && !forceUpdate) {
    console.log(`✅ Already in sync with AdCP v${adcpVersion}`);
    generateVersionFile(currentLibraryVersion, adcpVersion);
    return;
  }
  
  if (currentAdcpVersion && currentAdcpVersion !== adcpVersion) {
    console.log(`🔄 AdCP version change detected: ${currentAdcpVersion} -> ${adcpVersion}`);
    
    if (!autoUpdate && !forceUpdate) {
      console.log(`⚠️  Use --auto-update to automatically bump library version`);
      console.log(`⚠️  Use --force to update AdCP version without changing library version`);
      process.exit(1);
    }
  }
  
  // Update versions
  updatePackageJsonVersion(adcpVersion, autoUpdate);
  
  console.log(`✅ Version sync completed`);
}

// CLI execution
if (require.main === module) {
  syncVersion().catch(error => {
    console.error('❌ Version sync failed:', error);
    process.exit(1);
  });
}

export { syncVersion, getCachedAdCPVersion };