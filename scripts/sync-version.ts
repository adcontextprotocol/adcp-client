#!/usr/bin/env tsx

import { readFileSync, writeFileSync, existsSync } from 'fs';
import path from 'path';

// Write file only if content differs (excluding generated timestamp)
function writeFileIfChanged(filePath: string, newContent: string): boolean {
  const contentWithoutTimestamp = (content: string) => {
    return content.replace(/generatedAt: '.*?'/, "generatedAt: '[TIMESTAMP]'");
  };

  let hasChanged = true;
  if (existsSync(filePath)) {
    const existingContent = readFileSync(filePath, 'utf8');
    const existingWithoutTimestamp = contentWithoutTimestamp(existingContent);
    const newWithoutTimestamp = contentWithoutTimestamp(newContent);

    if (existingWithoutTimestamp === newWithoutTimestamp) {
      hasChanged = false;
    }
  }

  if (hasChanged) {
    writeFileSync(filePath, newContent);
  }

  return hasChanged;
}

// Get target AdCP version from ADCP_VERSION file (source of truth)
function getTargetAdCPVersion(): string {
  try {
    const versionFilePath = path.join(__dirname, '../ADCP_VERSION');
    if (!existsSync(versionFilePath)) {
      throw new Error('ADCP_VERSION file not found. This file defines which AdCP version to use.');
    }
    const version = readFileSync(versionFilePath, 'utf8').trim();
    if (!version) {
      throw new Error('ADCP_VERSION file is empty');
    }
    return version;
  } catch (error) {
    console.error(`âŒ Failed to read ADCP_VERSION file:`, error.message);
    process.exit(1);
  }
}

// Get current package.json version
function getCurrentPackageVersion(): { version: string; adcpVersion?: string } {
  try {
    const packagePath = path.join(__dirname, '../package.json');
    const packageJson = JSON.parse(readFileSync(packagePath, 'utf8'));
    return {
      version: packageJson.version,
      adcpVersion: packageJson.adcp_version,
    };
  } catch (error) {
    console.error(`âŒ Failed to read package.json:`, error.message);
    process.exit(1);
  }
}

// Generate version.ts file with library and AdCP versions
function generateVersionFile(libraryVersion: string, adcpVersion: string): void {
  const versionFilePath = path.join(__dirname, '../src/lib/version.ts');
  const versionContent = `// Generated version information
// This file is auto-generated by sync-version.ts

/**
 * AdCP client library version
 */
export const LIBRARY_VERSION = '${libraryVersion}';

/**
 * AdCP specification version this library is built for
 */
export const ADCP_VERSION = '${adcpVersion}';

/**
 * AdCP versions this library maintains backward compatibility with
 */
export const COMPATIBLE_ADCP_VERSIONS = ['v2.5', 'v2.6', 'v3', '3.0.0-beta.1'] as const;

/**
 * Full version information
 */
export const VERSION_INFO = {
  library: '${libraryVersion}',
  adcp: '${adcpVersion}',
  compatibleVersions: COMPATIBLE_ADCP_VERSIONS,
  generatedAt: '${new Date().toISOString()}',
} as const;

/**
 * Get the AdCP specification version this library is built for
 */
export function getAdcpVersion(): string {
  return ADCP_VERSION;
}

/**
 * Get the library version
 */
export function getLibraryVersion(): string {
  return LIBRARY_VERSION;
}

/**
 * Check if this library version is compatible with a given AdCP version
 */
export function isCompatibleWith(adcpVersion: string): boolean {
  return (COMPATIBLE_ADCP_VERSIONS as readonly string[]).includes(adcpVersion);
}

/**
 * Get all AdCP versions this library is compatible with
 */
export function getCompatibleVersions(): readonly string[] {
  return COMPATIBLE_ADCP_VERSIONS;
}
`;

  const versionChanged = writeFileIfChanged(versionFilePath, versionContent);
  if (versionChanged) {
    console.log(`âœ… Updated version file: ${versionFilePath}`);
  } else {
    console.log(`âœ… Version file is up to date: ${versionFilePath}`);
  }
}

// Update package.json with AdCP version
function updatePackageJsonVersion(adcpVersion: string, autoUpdate: boolean = false): void {
  const packagePath = path.join(__dirname, '../package.json');
  const packageJson = JSON.parse(readFileSync(packagePath, 'utf8'));

  const currentLibraryVersion = packageJson.version;
  const currentAdcpVersion = packageJson.adcp_version;

  // Check if AdCP version has changed
  if (currentAdcpVersion === adcpVersion) {
    console.log(`âœ… Package already aligned with AdCP v${adcpVersion}`);
    generateVersionFile(currentLibraryVersion, adcpVersion);
    return;
  }

  // Update adcp_version field
  packageJson.adcp_version = adcpVersion;

  if (autoUpdate) {
    // Auto-increment library version when AdCP version changes
    const [major, minor, patch] = currentLibraryVersion.split('.').map(Number);

    // Determine version bump strategy based on AdCP version change
    const [currentMajor, currentMinor] = (currentAdcpVersion || '0.0.0').split('.').map(Number);
    const [newMajor, newMinor] = adcpVersion.split('.').map(Number);

    let newLibraryVersion: string;

    if (newMajor > currentMajor) {
      // Major AdCP version change -> bump major library version
      newLibraryVersion = `${major + 1}.0.0`;
    } else if (newMinor > currentMinor) {
      // Minor AdCP version change -> bump minor library version
      newLibraryVersion = `${major}.${minor + 1}.0`;
    } else {
      // Patch AdCP version change -> bump patch library version
      newLibraryVersion = `${major}.${minor}.${patch + 1}`;
    }

    packageJson.version = newLibraryVersion;
    console.log(`ğŸ“ˆ Auto-updating library version: ${currentLibraryVersion} -> ${newLibraryVersion}`);
  }

  // Write updated package.json
  writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + '\n');
  console.log(`âœ… Updated package.json:`);
  console.log(`   ğŸ“¦ Library version: ${packageJson.version}`);
  console.log(`   ğŸ·ï¸  AdCP version: ${adcpVersion}`);

  // Generate version file
  generateVersionFile(packageJson.version, adcpVersion);
}

// Main sync function
async function syncVersion(): Promise<void> {
  console.log('ğŸ”„ Syncing version with AdCP specification...');

  // Get current state
  const adcpVersion = getTargetAdCPVersion();
  const { version: currentLibraryVersion, adcpVersion: currentAdcpVersion } = getCurrentPackageVersion();

  console.log(`ğŸ“‹ Current state:`);
  console.log(`   ğŸ“¦ Library version: ${currentLibraryVersion}`);
  console.log(`   ğŸ·ï¸  Current AdCP version: ${currentAdcpVersion || 'not set'}`);
  console.log(`   ğŸ¯ Target AdCP version: ${adcpVersion} (from ADCP_VERSION file)`);

  // Check command line arguments
  const args = process.argv.slice(2);
  const autoUpdate = args.includes('--auto-update') || args.includes('-u');
  const forceUpdate = args.includes('--force') || args.includes('-f');

  if (currentAdcpVersion === adcpVersion && !forceUpdate) {
    console.log(`âœ… Already in sync with AdCP v${adcpVersion}`);
    generateVersionFile(currentLibraryVersion, adcpVersion);
    return;
  }

  if (currentAdcpVersion && currentAdcpVersion !== adcpVersion) {
    console.log(`ğŸ”„ AdCP version change detected: ${currentAdcpVersion} -> ${adcpVersion}`);

    if (!autoUpdate && !forceUpdate) {
      console.log(`âš ï¸  Use --auto-update to automatically bump library version`);
      console.log(`âš ï¸  Use --force to update AdCP version without changing library version`);
      process.exit(1);
    }
  }

  // Update versions
  updatePackageJsonVersion(adcpVersion, autoUpdate);

  console.log(`âœ… Version sync completed`);
}

// CLI execution
if (require.main === module) {
  syncVersion().catch(error => {
    console.error('âŒ Version sync failed:', error);
    process.exit(1);
  });
}

export { syncVersion, getTargetAdCPVersion };
