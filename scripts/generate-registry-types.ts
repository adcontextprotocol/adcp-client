#!/usr/bin/env tsx

/**
 * Generate TypeScript types from the AdCP Registry OpenAPI spec.
 *
 * Usage:
 *   npm run generate-registry-types          # Use cached spec
 *   npm run generate-registry-types -- --sync # Download fresh spec first
 */

import { writeFileSync, readFileSync, existsSync, mkdirSync } from 'fs';
import path from 'path';
import { pathToFileURL } from 'url';

const REGISTRY_SPEC_URL = 'https://adcontextprotocol.org/openapi/registry.yaml';
const SCHEMA_DIR = path.join(__dirname, '../schemas/registry');
const CACHED_SPEC = path.join(SCHEMA_DIR, 'registry.yaml');
const OUTPUT_FILE = path.join(__dirname, '../src/lib/registry/types.generated.ts');

function writeFileIfChanged(filePath: string, newContent: string): boolean {
  const contentWithoutTimestamp = (content: string) =>
    content.replace(/\/\/ Generated at: .*?\n/, '// Generated at: [TIMESTAMP]\n');

  if (existsSync(filePath)) {
    const existing = readFileSync(filePath, 'utf8');
    if (contentWithoutTimestamp(existing) === contentWithoutTimestamp(newContent)) {
      return false;
    }
  }

  writeFileSync(filePath, newContent);
  return true;
}

async function syncSpec(): Promise<void> {
  console.log(`Downloading registry spec from ${REGISTRY_SPEC_URL}...`);
  const res = await fetch(REGISTRY_SPEC_URL);
  if (!res.ok) throw new Error(`Failed to fetch spec: ${res.status} ${res.statusText}`);
  const yaml = await res.text();
  mkdirSync(SCHEMA_DIR, { recursive: true });
  writeFileSync(CACHED_SPEC, yaml);
  console.log(`Cached at ${CACHED_SPEC} (${yaml.length} bytes)`);
}

async function generate(): Promise<void> {
  const shouldSync = process.argv.includes('--sync');

  if (shouldSync || !existsSync(CACHED_SPEC)) {
    await syncSpec();
  }

  // Dynamic import since openapi-typescript is ESM-only
  const { default: openapiTS, astToString } = await import('openapi-typescript');

  console.log('Generating types from cached spec...');
  const specUrl = pathToFileURL(CACHED_SPEC);
  const ast = await openapiTS(specUrl);
  const rawOutput = astToString(ast);

  // Build the output file with ergonomic re-exports
  const header = `// Generated AdCP Registry types from OpenAPI spec
// Generated at: ${new Date().toISOString()}
// Source: ${REGISTRY_SPEC_URL}
//
// Do not edit this file manually. Run: npm run generate-registry-types
`;

  const content = `${header}
${rawOutput}

// ====== Ergonomic type aliases ======
// Re-export component schemas as standalone types for direct import

export type ResolvedBrand = components['schemas']['ResolvedBrand'];
export type LocalizedName = components['schemas']['LocalizedName'];
export type BrandRegistryItem = components['schemas']['BrandRegistryItem'];
export type ResolvedProperty = components['schemas']['ResolvedProperty'];
export type PropertyIdentifier = components['schemas']['PropertyIdentifier'];
export type PropertyRegistryItem = components['schemas']['PropertyRegistryItem'];
export type ValidationResult = components['schemas']['ValidationResult'];
export type RegistryError = components['schemas']['Error'];
export type PublisherPropertySelector = components['schemas']['PublisherPropertySelector'];
export type FederatedAgentWithDetails = components['schemas']['FederatedAgentWithDetails'];
export type AgentHealth = components['schemas']['AgentHealth'];
export type AgentStats = components['schemas']['AgentStats'];
export type AgentCapabilities = components['schemas']['AgentCapabilities'];
export type PropertySummary = components['schemas']['PropertySummary'];
export type FederatedPublisher = components['schemas']['FederatedPublisher'];
export type DomainLookupResult = components['schemas']['DomainLookupResult'];
`;

  const changed = writeFileIfChanged(OUTPUT_FILE, content);
  if (changed) {
    console.log(`Generated ${OUTPUT_FILE} (${content.length} bytes)`);
  } else {
    console.log('No changes detected, file unchanged.');
  }
}

generate().catch((err) => {
  console.error('Error generating registry types:', err.message);
  process.exit(1);
});
